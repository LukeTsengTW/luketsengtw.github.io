<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2 | Yaoの程式小窩</title><meta name="author" content="LukeTseng"><meta name="copyright" content="LukeTseng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2 本筆記僅供個人學習用途，內容斟酌參考。  1. Convert Sorted Array to Binary Search Tree Problem Source：https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;convert-sorted-array-to-binary-search-"><meta property="og:type" content="article"><meta property="og:title" content="【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2"><meta property="og:url" content="https://luketsengtw.github.io/posts/e9485c30"><meta property="og:site_name" content="Yaoの程式小窩"><meta property="og:description" content="【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2 本筆記僅供個人學習用途，內容斟酌參考。  1. Convert Sorted Array to Binary Search Tree Problem Source：https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;convert-sorted-array-to-binary-search-"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://luketsengtw.github.io/img/leetcode_cover.png"><meta property="article:published_time" content="2025-09-13T13:01:28.000Z"><meta property="article:modified_time" content="2025-09-13T13:04:38.673Z"><meta property="article:author" content="LukeTseng"><meta property="article:tag" content="C++"><meta property="article:tag" content="程式設計"><meta property="article:tag" content="演算法"><meta property="article:tag" content="程式語言"><meta property="article:tag" content="資料結構"><meta property="article:tag" content="競程"><meta property="article:tag" content="CP"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://luketsengtw.github.io/img/leetcode_cover.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【Leetcode C++ 解題筆記】Divide & Conquer - part 2",
  "url": "https://luketsengtw.github.io/posts/e9485c30",
  "image": "https://luketsengtw.github.io/img/leetcode_cover.png",
  "datePublished": "2025-09-13T13:01:28.000Z",
  "dateModified": "2025-09-13T13:04:38.673Z",
  "author": [
    {
      "@type": "Person",
      "name": "LukeTseng",
      "url": "https://luketsengtw.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/website_favicon.ico"><link rel="canonical" href="https://luketsengtw.github.io/posts/e9485c30"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="S50ZW5JR-4iAagicR6omYnAz8LUv5ZcouskPpuBaFBs"><link rel="manifest" href="/img/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-7EES35MTFS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-7EES35MTFS"),btf.addGlobalFn("pjaxComplete",()=>{gtag("config","G-7EES35MTFS",{page_path:window.location.pathname})},"google_analytics")</script><script>!function(e,t,a,n,o){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var g=t.getElementsByTagName(a)[0],m=t.createElement(a);m.async=!0,m.src="https://www.googletagmanager.com/gtm.js?id=GTM-5BKRW8SL",g.parentNode.insertBefore(m,g)}(window,document,"script","dataLayer"),btf.addGlobalFn("pjaxComplete",()=>{dataLayer.push({event:"pjaxComplete",page_title:document.title,page_location:location.href,page_path:window.location.pathname})},"google_tag_manager")</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"EF32H7JNEE",apiKey:"876fdde0317458bcae93bc0ded1d7176",indexName:"hexo",hitsPerPage:10,languages:{input_placeholder:"想找些什麼呢...?",hits_empty:"找不到符合您查詢的內容：${query}",hits_stats:"找到 ${hits} 筆結果，耗時 ${time} 毫秒"}},localSearch:void 0,translate:{defaultEncoding:1,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!0,highlightMacStyle:!0},copy:{success:"複製成功",error:"複製失敗",noSupport:"瀏覽器不支援"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"剛剛",min:"分鐘前",hour:"小時前",day:"天前",month:"個月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"已切換為繁體中文",cht_to_chs:"已切換為簡體中文",day_to_night:"已切換為深色模式",night_to_day:"已切換為淺色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"載入更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Leetcode C++ 解題筆記】Divide & Conquer - part 2",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Yaoの程式小窩" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><script>(()=>{const e=document.getElementById("loading-box"),d=document.body,t=()=>{e.classList.contains("loaded")||(d.style.overflow="",e.classList.add("loaded"))},o=()=>{d.style.overflow="hidden",e.classList.remove("loaded")};o(),"complete"===document.readyState?t():(window.addEventListener("load",t),document.addEventListener("DOMContentLoaded",t),setTimeout(t,7e3))})()</script><div id="web_bg" style="background-image:url(/img/web_background_smaller.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">212</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/leetcode_cover.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/icon.png" alt="Logo"><span class="site-name">Yaoの程式小窩</span></a><a class="nav-page-title" href="/"><span class="site-name">【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> 返回首頁</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜尋</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2025-09-13T13:01:28.000Z" title="發表於 2025-09-13 21:01:28">2025-09-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-09-13T13:04:38.673Z" title="更新於 2025-09-13 21:04:38">2025-09-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/competitive-programming/">競程</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/competitive-programming/CP-question/">解題</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/competitive-programming/CP-question/leetcode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">總字數:</span><span class="word-count">2.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時間:</span><span>9分鐘</span></span><span class="post-meta-separator">|</span><span data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span class="waline-pageview-count" data-path="/posts/e9485c30"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">評論數:</span><a href="/posts/e9485c30#post-comment"><span class="waline-comment-count" data-path="/posts/e9485c30"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="leetcode-c-解題筆記divide-conquer-part-2"><a class="markdownIt-Anchor" href="#leetcode-c-解題筆記divide-conquer-part-2"></a> 【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2</h1><p>本筆記僅供個人學習用途，內容斟酌參考。</p><h2 id="1-convert-sorted-array-to-binary-search-tree"><a class="markdownIt-Anchor" href="#1-convert-sorted-array-to-binary-search-tree"></a> 1. Convert Sorted Array to Binary Search Tree</h2><p>Problem Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/?envType=problem-list-v2&amp;envId=divide-and-conquer">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/?envType=problem-list-v2&amp;envId=divide-and-conquer</a></p><p>難度：Easy</p><p>題意大致上就是要你把一般常見的陣列轉換成 BST。</p><p>補充一下 BST 特性：</p><ul><li>左子樹的 Nodes 都比 Root 還小；反之，右子樹都比 Root 還大。</li><li>子樹必須都是 BST。</li></ul><p>解題思路：</p><p>用到 Divide &amp; Conquer 的概念，每次把「目前」陣列片段選中間元素作為 root。</p><p>對 root 左側遞迴呼叫產生左子樹，右側也一樣，直到子陣列長度為 0 就結束。</p><p>範例程式碼：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildBST</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildBST</span><span class="params">(vector &lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]); <span class="comment">// root</span></span><br><span class="line">        node -&gt; left = <span class="built_in">buildBST</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        node -&gt; right = <span class="built_in">buildBST</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-majority-element"><a class="markdownIt-Anchor" href="#2-majority-element"></a> 2. Majority Element</h2><p>Problem Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode.com/problems/majority-element/description/?envType=problem-list-v2&amp;envId=divide-and-conquer">https://leetcode.com/problems/majority-element/description/?envType=problem-list-v2&amp;envId=divide-and-conquer</a></p><p>難度：Easy</p><p>題目敘述：</p><p>給定長度為 n 的陣列 nums，回傳多數元素（the majority element）。</p><p>所謂多數元素就是元素出現超過 <code>[n / 2]</code> 次。你可以假設它都會出現在陣列中。</p><p>解題思路：</p><p>用 Divide &amp; Conquer 做這題，一樣是二分法去做，主要處理 <code>[left, mid]</code> 和 <code>[mid + 1, right]</code> 這兩段區間。</p><p>終止條件是 <code>if (left == right) return nums[left];</code> 表示元素個數剩一個，該元素必為多數元素，故回傳此值。</p><p>遞迴處理 lm 和 rm 的部分（左右區間）。</p><p>之後做合併動作，也直接做判斷：<code>if (lm == rm) return lm;</code> 表示左右多數元素相同。</p><p>如果不同，就需要去數 lm 跟 rm 共出現幾次：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c1 = <span class="built_in">count</span>(nums.<span class="built_in">begin</span>() + left, nums.<span class="built_in">begin</span>() + right + <span class="number">1</span>, lm);</span><br><span class="line"><span class="type">int</span> c2 = <span class="built_in">count</span>(nums.<span class="built_in">begin</span>() + left, nums.<span class="built_in">begin</span>() + right + <span class="number">1</span>, rm);</span><br><span class="line"><span class="keyword">return</span> c1 &gt; c2 ? lm : rm;</span><br></pre></td></tr></table></figure><p>範例程式碼：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">majority</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majority</span><span class="params">(vector &lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> lm = <span class="built_in">majority</span>(nums, left, mid);</span><br><span class="line">        <span class="type">int</span> rm = <span class="built_in">majority</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">if</span> (lm == rm) <span class="keyword">return</span> lm;</span><br><span class="line">        <span class="type">int</span> c1 = <span class="built_in">count</span>(nums.<span class="built_in">begin</span>() + left, nums.<span class="built_in">begin</span>() + right + <span class="number">1</span>, lm);</span><br><span class="line">        <span class="type">int</span> c2 = <span class="built_in">count</span>(nums.<span class="built_in">begin</span>() + left, nums.<span class="built_in">begin</span>() + right + <span class="number">1</span>, rm);</span><br><span class="line">        <span class="keyword">return</span> c1 &gt; c2 ? lm : rm; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-reverse-bits"><a class="markdownIt-Anchor" href="#3-reverse-bits"></a> 3. Reverse Bits</h2><p>Problem Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode.com/problems/reverse-bits/description/?envType=problem-list-v2&amp;envId=divide-and-conquer">https://leetcode.com/problems/reverse-bits/description/?envType=problem-list-v2&amp;envId=divide-and-conquer</a></p><p>難度：Easy</p><p>題目敘述：</p><p>反轉 32 位元的偶數有號整數（uint）。</p><p>先以 8 位元舉例比較好懂，32 位元太長了。</p><p>假設原本數字是 0 0 0 1 0 1 1 0，二進位是從右開始為起始索引，最左邊是最終索引 7。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Index :7 6 5 4 3 2 1 0</span><br><span class="line">       0 0 0 1 0 1 1 0</span><br></pre></td></tr></table></figure><p>所謂反轉位元的意思就是把索引顛倒：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Index :0 1 2 3 4 5 6 7</span><br><span class="line">       0 1 1 0 1 0 0 0</span><br></pre></td></tr></table></figure><p>就這樣。</p><p>範例程式碼：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本上這段程式碼就是不斷將 n 切割成兩部分，並且作互換（用 <code>|</code> OR 運算子互換）的動作，以此來達到反轉位元的效果。</p><h2 id="4-number-of-1-bits"><a class="markdownIt-Anchor" href="#4-number-of-1-bits"></a> 4. Number of 1 Bits</h2><p>Problem Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode.com/problems/number-of-1-bits/description/?envType=problem-list-v2&amp;envId=divide-and-conquer">https://leetcode.com/problems/number-of-1-bits/description/?envType=problem-list-v2&amp;envId=divide-and-conquer</a></p><p>難度：Easy</p><p>題目敘述：</p><p>給定一個正整數 n，寫一個函數回傳其二進位表示法中的設定位數（也稱為漢明權重）。</p><p>set bits 指的是有 1 的位元數量，如 1011 就有 3 個 set bits，這個也稱為 Hamming weight。</p><p>範例程式碼講解：</p><p>雖然有 <code>std::popcount</code>（C++ 20） 或 <code>__builtin_popcount()</code>（看編譯器支不支援）可以用，但上述兩種方法若在某些競賽上使用可能不切實際。</p><p>所以我們來手刻一下 popcount。</p><p>在細講這個演算法之前，我們要先知道幾個 bitmasks：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x55 = 01010101</span><br><span class="line">0x33 = 00110011</span><br><span class="line">0x0f = 00001111</span><br><span class="line">0xff = 11111111</span><br></pre></td></tr></table></figure><p>第一行（<code>n = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555);</code>）用到 bitmasks <code>0x55</code>，挑出 n 中所有在奇數位（bit 0, 2, 4, …）的 bit，再把 n 右移 1 位後（偶數位），也用相同遮罩挑出偶數位 bit，最後兩者相加。</p><p>這一層分治主要將 32 個 bit 分成 16 組，每組 2bit。</p><p>第二行（<code>n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333);</code>）用到 bitmasks <code>0x33</code>，將剛才算好的每 2bit 組做累加操作，把相鄰的兩個 2bit 組合成一個 4bit 組並累加 1 的數量。</p><p>然後這層分治也將 32bit 分成 8 組，每組 4bit，計算每組內 1 的個數。</p><p>第三行（<code>n = (n &amp; 0x0f0f0f0f) + ((n &gt;&gt; 4) &amp; 0x0f0f0f0f);</code>）用到 bitmasks <code>0x0f</code>，將相鄰的兩個 4bit 組合成一個 8bit 組，同樣使用 bitmasks 分低 4bit 及高 4bit 相加。</p><p>該層分治再把 32bit 分成 4 組，每組 8bit，計算每組內 1 的個數。</p><p>第四行（<code>n = (n &amp; 0x00ff00ff) + ((n &gt;&gt; 8) &amp; 0x00ff00ff);</code>）也用到一樣的 bitmasks，只不過多加個 f，在二進位上就多了四個 f。</p><p>這層分治把將相鄰兩個 8bit 組合成 1 個 16bit 組，再累加各 8bit 中 1 的個數。</p><p>第五行（<code>n = (n &amp; 0x0000ffff) + ((n &gt;&gt; 16) &amp; 0x0000ffff);</code>）用到最後一個 bitmasks <code>0xff</code>，將兩個 16bit 組合成整個 32bit 的組合，再將前後 16bit 中 1 的個數合併。</p><p>最終我們就從 32 bit 裡面得到所有 1 的數量了，為什麼是 32 bit 呢？因為題目要求 int，int 就剛好 32 bit。</p><p>完整範例程式碼：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">        n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">        n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-longest-nice-substring"><a class="markdownIt-Anchor" href="#5-longest-nice-substring"></a> 5. Longest Nice Substring</h2><p>Problem Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode.com/problems/longest-nice-substring/description/?envType=problem-list-v2&amp;envId=divide-and-conquer">https://leetcode.com/problems/longest-nice-substring/description/?envType=problem-list-v2&amp;envId=divide-and-conquer</a></p><p>難度：Easy</p><p>題目敘述：</p><p>一字串 s 如果是 nice，那對於每個字母表中的每個字母都包含 s，它以大寫和小寫形式出現。</p><p>舉例來說，<code>&quot;abABB&quot;</code> 是 nice，因為 <code>'A'</code> 和 <code>'a'</code> 出現，並且 <code>'B'</code> 和 <code>'b'</code> 出現。然而，<code>&quot;abA&quot;</code> 不是 nice，因為 <code>'b'</code> 出現，而 <code>'B'</code> 沒有出現。</p><p>給定一個字串 s，回傳 s 中最長的、滿足 nice 條件的子字串。如果有多個，則回傳最早出現的子字串。如果沒有，則傳回空字串。</p><p>解題思路：</p><p>我們用資料結構 <code>unordered_set &lt;int&gt; seen(s.begin(), s.end());</code> 來實作這題。</p><p>首先跑迴圈，內部判斷一個字串中的字元 c 有沒有其他相反的大小寫，如 A 要找到對應的小寫 a 才是一個 nice substring。（這邊要找他對應相反的大小寫，我們用 <code>seen.find()</code> 去找）</p><p>大小寫判斷可以額外寫一個 <code>toggleCase()</code> 函數去判斷，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">toggleCase</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(c)) <span class="keyword">return</span> <span class="built_in">toupper</span>(c);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">tolower</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>seen.find()</code> 沒有找到，則回傳 <code>end()</code> 這個 iterator。</p><p>沒找到的話我們就要做遞迴去找了，這邊用分治法的概念將字串切兩半去找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string left = <span class="built_in">longestNiceSubstring</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, i));</span><br><span class="line">string right = <span class="built_in">longestNiceSubstring</span>(s.<span class="built_in">substr</span>(i + <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><code>substr(0, i)</code> 為從索引 0 開始，擷取長度 i 的子字串（不含索引 i 的字元），形成左半邊的子字串。</p><p><code>substr(i + 1)</code> 從索引 i + 1 開始，擷取到字串尾的子字串，形成右半邊子字串。</p><p>最後回傳較長的子字串：<code>return left.size() &gt;= right.size() ? left : right</code>。</p><p>最後的最後，如果我們前面判斷都沒有回傳 <code>end()</code> 的話，那就表示說整串字串完美符合 nice substring 的條件，就直接 <code>return s</code>。</p><p>完整範例程式碼：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestNiceSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        unordered_set &lt;<span class="type">char</span>&gt; <span class="built_in">seen</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.<span class="built_in">find</span>(<span class="built_in">toggleCase</span>(s[i])) == seen.<span class="built_in">end</span>())&#123;</span><br><span class="line">                string left = <span class="built_in">longestNiceSubstring</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, i));</span><br><span class="line">                string right = <span class="built_in">longestNiceSubstring</span>(s.<span class="built_in">substr</span>(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">return</span> left.<span class="built_in">size</span>() &gt;= right.<span class="built_in">size</span>() ? left : right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">toggleCase</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">islower</span>(c)) <span class="keyword">return</span> <span class="built_in">toupper</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">tolower</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://luketsengtw.github.io">LukeTseng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://luketsengtw.github.io/posts/e9485c30">https://luketsengtw.github.io/posts/e9485c30</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://luketsengtw.github.io" target="_blank">Yaoの程式小窩</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/">程式設計</a><a class="post-meta__tags" href="/tags/%E6%BC%94%E7%AE%97%E6%B3%95/">演算法</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/">程式語言</a><a class="post-meta__tags" href="/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/">資料結構</a><a class="post-meta__tags" href="/tags/%E7%AB%B6%E7%A8%8B/">競程</a><a class="post-meta__tags" href="/tags/CP/">CP</a></div><div class="post-share"><div class="social-share" data-image="/img/leetcode_cover.png" data-sites="facebook, twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/16431172" title="2025 VMWare Workstation Pro 免費安裝教學"><img class="cover" src="/img/vmware_icon.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">2025 VMWare Workstation Pro 免費安裝教學</div></div><div class="info-2"><div class="info-item-1">2025 VMWare Workstation Pro 免費安裝教學 大家好，我是 LukeTseng，現在的 VMWare Workstation Pro 已經轉免費了，但是安裝流程有些繁瑣，在此我來幫助各位解決這個問題！ 本篇教學主要以新手向為主，透過一步、一做的流程進行教學。 若本篇教學文章有誤，懇請勘誤，感謝您。 先開啟 VT 虛擬化技術功能！ 我們要玩虛擬機之前，無論是你曾玩過什麼 BlueStacks、夜神模擬器，那些都需要開啟所謂的 VT 虛擬化技術，才能順跑。 不開也是可以，只是會讓你用到懷疑人生。 我如何確認已經開啟 VT？很簡單，先到我們的工作列空白處按下滑鼠右鍵，開啟工作管理員。 開啟之後在視窗左側欄位點選【效能】選項。 點擊我們的 CPU 欄位，可看到模擬是否已啟用，啟用的話就是有開 VT。 在開啟這個之前呢，我們需要進入電腦的 BIOS 系統，以下是個人電腦（PC）與筆電端的操作方式： HP：https://www.hp.com/hk-zh/shop/tech-takes/post/如何在-windows-個人電腦上進入-bios-設置 ASU...</div></div></div></a><a class="pagination-related" href="/posts/54836959" title="【Python 網路爬蟲筆記】Introduction - part 1"><img class="cover" src="/img/python_cover.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【Python 網路爬蟲筆記】Introduction - part 1</div></div><div class="info-2"><div class="info-item-1">【Python 網路爬蟲筆記】Introduction - part 1 感謝你點進本篇文章！！我是 LukeTseng，一個熱愛資訊的無名創作者，由於近期大學開設大數據分析程式設計這門課程，裡面談到了爬蟲概念，讓我激起一些興趣，因而製作本系列筆記。 聲明：本篇筆記僅供個人學習用途，斟酌參考。 何謂網路爬蟲（Web Crawler）？ Image Source：https://www.freepik.com/free-vector/cute-spider-sticker-white-background_20770625.htm#fromView=keyword&amp;page=1&amp;position=48&amp;uuid=58458110-a248-4037-895d-b6b66f71a92b&amp;query=Spider+cartoon 網路爬蟲（Web Crawler），也叫網路蜘蛛，是一種用來自動瀏覽全球資訊網的網路機器人。其目的一般為編纂網路索引。 From WikiPedia 網路爬蟲最主要的用處是可以「自動化」幫我們擷取及收集想要的資訊。 一...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/8a073873" title="【C++】競程筆記（多維 DP、LCS 最長共同子序列 習題練習）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-01</div><div class="info-item-2">【C++】競程筆記（多維 DP、LCS 最長共同子序列 習題練習）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（多維 DP、LCS 最長共同子序列 習題練習） 練習題目參考自：NTUCPC Guide，此筆記僅為個人學習用途。 823 . RGB Problem Source：https://oj.ntucpc.org/problems/823 先定義三種顏色的代號以及對分數的貢獻（權重）： 紅色（j=0j=0j=0）：權重為 −vi-v_i−vi​（題目要求扣掉紅色數字總和）。 綠色（j=1j=1j=1）：權重為 +vi+v_i+vi​（題目要求加上綠色數字總和）。 藍色（j=2j=2j=2）：權重為 000（藍色不影響分數）。 最後再來定義狀態：定義 dp[i][j]dp[i][j]dp[i][j] 為考慮到第 iii 個數字，且將第 iii 個數字塗上顏色 jjj 時，目前所能獲得的最大價值。 i:1≤i≤Ni : 1 \le i \le Ni:1≤i≤N j:0≤j≤2j : 0 \le j \le 2j:0≤j≤2 （分別代表紅、綠、藍） 求 DP 轉移式： 題目限制「相鄰的數字必須標上不同的顏色」，要計算第 iii 個數字塗某個顏色時，第 i−1...</div></div></div></a><a class="pagination-related" href="/posts/9557eed6" title="【C++】競程筆記（DP：狀態跟轉移）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-21</div><div class="info-item-2">【C++】競程筆記（DP：狀態跟轉移）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（DP：狀態跟轉移） 題目範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 非線性遞迴題型 481 . [Tutorial] 別離太遠 續 Problem Source：https://oj.ntucpc.org/problems/481 這題要求的不是方法數，而是「最大值」。 這題的上一題已經知道要怎麼求方法數了，結果就是一個費氏數列，而這次要求的是讓每個人的能力值總和到最大，那該怎麼求呢？ 遞迴式長得差不多，先定義 base case： a1,n=1a_1, n = 1a1​,n=1 a1+a2,n=2a_1 + a_2, n = 2a1​+a2​,n=2 剩下的情況可以寫成 max(f(n−1),f(n−2))+anmax(f(n - 1), f(n - 2)) + a_nmax(f(n−1),f(n−2))+an​ ，因為要最大化能力值，所以從第 n 個的前兩位（編號差不能超過 2）挑出最大的那個。 範例程式碼： 1234567891011121314151617181920212223#include &lt;bits/stdc++...</div></div></div></a><a class="pagination-related" href="/posts/a6f0427e" title="【C++】競程筆記（多維 DP、LCS 最長共同子序列）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-27</div><div class="info-item-2">【C++】競程筆記（多維 DP、LCS 最長共同子序列）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（多維 DP、LCS 最長共同子序列） 題目範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 什麼是多維的 DP? 一開始入門 DP 所寫的全都是一維的 DP，例如在爬樓梯問題， dp[i]dp[i]dp[i] 就表示成到達第 iii 階的方法數。 而當中只有一個變數，叫做 iii ，故稱為一維 DP。 多維的 DP 就是有多個變數的 DP，一個變數不足以清楚描述當前的子問題，需要兩個或更多的變數來鎖定狀態。 例如： 走迷宮需要 x,yx, yx,y 座標兩個變數來表示 dp[x][y]dp[x][y]dp[x][y] LCS（Longest Common Subsequence：最長共同子序列）需要字串 A 的位置 iii 和字串 B 的位置 jjj 表示 dp[i][j]dp[i][j]dp[i][j] 背包問題：需要物品編號 iii 和剩餘重量 www 表示 dp[i][w]dp[i][w]dp[i][w] Vacation Problem Source：https://atcoder.jp/contests/dp/tasks/dp_...</div></div></div></a><a class="pagination-related" href="/posts/553f4c10" title="【C++】競程筆記（BFS：廣度優先搜尋）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-07</div><div class="info-item-2">【C++】競程筆記（BFS：廣度優先搜尋）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（BFS：廣度優先搜尋） 程式碼範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 流水問題 以 NTUCPC Guide 舉的例子來說的話，水流只能往上下左右流，而且是同時流，然後求每個空地格子幾秒後會有水。 具體做法是先將流水的起點定為 0 秒，之後向上下左右擴散一單位的水並 + 1 秒，注意這邊要做邊界檢查，如下圖的第三張。 Image Source：https://guide.ntucpc.org/AlgorithmTechnique/bfs/ 而在程式設計上，右上角那塊 2 是最容易犯錯的，因為我們都想說上下左右 + 1，第一次寫的時候會沒想到那塊 2 左邊跟下方都有一塊 1，最後加起來還可能會是 3，就比較不合理，這也是要在程式設計上要注意的地方。 以下是有關這個流水問題的範例程式碼（From : NTUCPC Guide | BFS）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// from NT...</div></div></div></a><a class="pagination-related" href="/posts/eb6151f4" title="【C++】競程筆記（DP：Top Down &amp; Bottom up）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-14</div><div class="info-item-2">【C++】競程筆記（DP：Top Down &amp; Bottom up）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（DP：Top Down &amp; Bottom up） 程式碼範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 Stack overflow Stack overflow 是一個 IT 論壇，然後在程式當中也會發生這種情形XD，有時候說 Stack overflow 也是一個雙關語。 至於 Stack overflow 是什麼呢？字面上意思就是堆疊溢位，是指程式使用過多的記憶體時導致呼叫堆疊產生的溢位。通常最常見的原因就是因為函式呼叫中使用到遞迴，導致遞迴過深。 遞迴的原理就是使用到了 stack 這個資料結構，每次呼叫會把值堆入堆疊，直到終止條件再將這些值一個一個拿出來。 94 . [Tutorial] 別離太遠 Problem Source：https://oj.ntucpc.org/problems/94 這題可以體會一下什麼叫做 stack overflow。 題目沒有給你 N = 1 跟 N = 2 的情況，但這兩個情況很簡單，稍微推算一下就可以知道方法數了。 N = 1：由於只有一個，所以方法數是 1。 N = 2：有 1 跟...</div></div></div></a><a class="pagination-related" href="/posts/79f429f" title="【C++】競程筆記（分治法 D&amp;C）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-25</div><div class="info-item-2">【C++】競程筆記（分治法 D&amp;C）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（分治法 D&amp;C） 程式碼範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 Introducing Divide and Conquer Divide and Conquer 英翻中為分治法，這是一個把大問題切分成多個子問題，最後從這些子問題合併來求得主問題解答的一種方法。 而 Divide and Conquer 的步驟主要有三項： Divide：把原問題拆成多個小且類似的子問題，直到無法再細分。 Conquer：用遞迴解決這些子問題；若遇到規模足夠小的「基本情況（base case）」，則直接輸出答案。 Merge：合併子問題得到最終解，一旦較小的子問題被解決，則遞迴合併所有子問題得到更大問題的答案。 例題：王老先生 Problem Source：https://tioj.sprout.tw/problems/114 題目敘述： 有個正方形土地 N×NN \times NN×N ， NNN 為 222 的正整數次方。 有一格子 (X,Y)(X, Y)(X,Y) 已被王老先生選走了，你要放 N×N−13\frac{N \times...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">LukeTseng</div><div class="author-info-description">一個軟硬體都愛的資訊人，也是個無名的程式熱愛者。目前仍主要活躍於 Hackmd 平台上，基本上本站與此同步更新。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">212</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/LukeTsengTW"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/LukeTsengTW" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#hdhfbb"></i></a><a class="social-icon" href="https://hackmd.io/@LukeTseng" rel="external nofollow noreferrer" target="_blank" title="Hackmd"><i class="fas fa-file-lines" style="color:#4e44fe"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-c-%E8%A7%A3%E9%A1%8C%E7%AD%86%E8%A8%98divide-conquer-part-2"><span class="toc-number">1.</span> <span class="toc-text">【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-convert-sorted-array-to-binary-search-tree"><span class="toc-number">1.1.</span> <span class="toc-text">1. Convert Sorted Array to Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-majority-element"><span class="toc-number">1.2.</span> <span class="toc-text">2. Majority Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-reverse-bits"><span class="toc-number">1.3.</span> <span class="toc-text">3. Reverse Bits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-number-of-1-bits"><span class="toc-number">1.4.</span> <span class="toc-text">4. Number of 1 Bits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-longest-nice-substring"><span class="toc-number">1.5.</span> <span class="toc-text">5. Longest Nice Substring</span></a></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>LeetCode 解題系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3ccc84f5" title="【Leetcode C++ 解題筆記】Stack - part 3"><img src="/img/leetcode_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Leetcode C++ 解題筆記】Stack - part 3"></a><div class="content"><a class="title" href="/posts/3ccc84f5" title="【Leetcode C++ 解題筆記】Stack - part 3">【Leetcode C++ 解題筆記】Stack - part 3</a><time datetime="2025-10-17T13:38:33.000Z" title="發表於 2025-10-17 21:38:33">2025-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e9485c30" title="【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2"><img src="/img/leetcode_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2"></a><div class="content"><a class="title" href="/posts/e9485c30" title="【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2">【Leetcode C++ 解題筆記】Divide &amp; Conquer - part 2</a><time datetime="2025-09-13T13:01:28.000Z" title="發表於 2025-09-13 21:01:28">2025-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f2bd77" title="【Leetcode C++ 解題筆記】Greedy - part 1"><img src="/img/leetcode_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Leetcode C++ 解題筆記】Greedy - part 1"></a><div class="content"><a class="title" href="/posts/8f2bd77" title="【Leetcode C++ 解題筆記】Greedy - part 1">【Leetcode C++ 解題筆記】Greedy - part 1</a><time datetime="2025-06-25T05:15:34.000Z" title="發表於 2025-06-25 13:15:34">2025-06-25</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f873b648" title="【計算機網路筆記】3.3 Connectionless Transport: UDP"><img src="/img/computer-network.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【計算機網路筆記】3.3 Connectionless Transport: UDP"></a><div class="content"><a class="title" href="/posts/f873b648" title="【計算機網路筆記】3.3 Connectionless Transport: UDP">【計算機網路筆記】3.3 Connectionless Transport: UDP</a><time datetime="2026-02-20T07:37:17.000Z" title="發表於 2026-02-20 15:37:17">2026-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f22075d" title="【計算機網路筆記】3.2 Multiplexing and Demultiplexing"><img src="/img/computer-network.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【計算機網路筆記】3.2 Multiplexing and Demultiplexing"></a><div class="content"><a class="title" href="/posts/f22075d" title="【計算機網路筆記】3.2 Multiplexing and Demultiplexing">【計算機網路筆記】3.2 Multiplexing and Demultiplexing</a><time datetime="2026-02-19T06:01:58.000Z" title="發表於 2026-02-19 14:01:58">2026-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9de58aa9" title="【計算機網路筆記】3.1 Introduction and Transport-Layer Services"><img src="/img/computer-network.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【計算機網路筆記】3.1 Introduction and Transport-Layer Services"></a><div class="content"><a class="title" href="/posts/9de58aa9" title="【計算機網路筆記】3.1 Introduction and Transport-Layer Services">【計算機網路筆記】3.1 Introduction and Transport-Layer Services</a><time datetime="2026-02-17T06:46:24.000Z" title="發表於 2026-02-17 14:46:24">2026-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/338e972c" title="【計算機網路筆記】2.7 Socket Programming: Creating Network Applications"><img src="/img/computer-network.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【計算機網路筆記】2.7 Socket Programming: Creating Network Applications"></a><div class="content"><a class="title" href="/posts/338e972c" title="【計算機網路筆記】2.7 Socket Programming: Creating Network Applications">【計算機網路筆記】2.7 Socket Programming: Creating Network Applications</a><time datetime="2026-02-16T08:40:05.000Z" title="發表於 2026-02-16 16:40:05">2026-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3546d36d" title="【計算機網路筆記】2.6 Video Streaming and Content Distribution Networks"><img src="/img/computer-network.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【計算機網路筆記】2.6 Video Streaming and Content Distribution Networks"></a><div class="content"><a class="title" href="/posts/3546d36d" title="【計算機網路筆記】2.6 Video Streaming and Content Distribution Networks">【計算機網路筆記】2.6 Video Streaming and Content Distribution Networks</a><time datetime="2026-02-15T09:36:23.000Z" title="發表於 2026-02-15 17:36:23">2026-02-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/leetcode_cover.png)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2024 - 2026 By LukeTseng</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主題 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="繁簡轉換">繁</button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"none"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{let e=window.walineFn||null;const n="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,t={lang:"zh-TW",locale:{seconds:"秒前",minutes:"分鐘前",hours:"小時前",days:"天前",now:"剛剛",gif:"表情包",gifSearchPlaceholder:"搜尋 gif 動圖",comment:"留言",placeholder:"歡迎留言，請務必友善發言，減少衝突，讓世界更美好～"},emoji:["https://unpkg.com/@waline/emojis@1.0.1/tw-emoji"]},i=(e,i=document,o=window.location.pathname)=>{const s=e({el:i.querySelector("#waline-wrap"),serverURL:"https://discussion-kohl.vercel.app/",pageview:!0,dark:'html[data-theme="dark"]',comment:!0,...t,path:n?o:t&&t.path||o});n&&(window.shuoshuoComment.destroyWaline=()=>{s.destroy(),i.children.length&&(i.innerHTML="",i.classList.add("no-comment"))})},o=(n,t)=>{e?i(e,n,t):btf.getCSS("https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css").then(()=>import("https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js")).then(({init:o})=>{e=o||Waline.init,i(e,n,t),window.walineFn=e})};n?window.shuoshuoComment={loadComment:o}:setTimeout(o,0)})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜尋</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5BKRW8SL" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div></body></html>