<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【考試向】資料結構筆記（鏈結串列） | Yaoの程式小窩</title><meta name="author" content="LukeTseng"><meta name="copyright" content="LukeTseng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【考試向】資料結構筆記（鏈結串列） 歡迎你點入本篇文章！我是 LukeTseng，本系列文章主要整理自學資料結構的一些知識，如果你喜歡我的文章，麻煩您不吝嗇的在文章底下按下一顆愛心，或是追蹤我唷～ 最後更新日期： 單向鏈結串列（Singly Linked list） 一般的陣列會在連續的記憶體空間中儲存資料。 鏈結串列可將資料儲存在不連續（non-contiguous）的記憶體空間中。 連續的壞處"><meta property="og:type" content="article"><meta property="og:title" content="【考試向】資料結構筆記（鏈結串列）"><meta property="og:url" content="https://luketsengtw.github.io/posts/ed071748"><meta property="og:site_name" content="Yaoの程式小窩"><meta property="og:description" content="【考試向】資料結構筆記（鏈結串列） 歡迎你點入本篇文章！我是 LukeTseng，本系列文章主要整理自學資料結構的一些知識，如果你喜歡我的文章，麻煩您不吝嗇的在文章底下按下一顆愛心，或是追蹤我唷～ 最後更新日期： 單向鏈結串列（Singly Linked list） 一般的陣列會在連續的記憶體空間中儲存資料。 鏈結串列可將資料儲存在不連續（non-contiguous）的記憶體空間中。 連續的壞處"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://luketsengtw.github.io/img/data_structure_cover.png"><meta property="article:published_time" content="2026-01-08T13:01:07.000Z"><meta property="article:modified_time" content="2026-01-19T05:01:35.237Z"><meta property="article:author" content="LukeTseng"><meta property="article:tag" content="程式設計"><meta property="article:tag" content="電腦"><meta property="article:tag" content="資料結構"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://luketsengtw.github.io/img/data_structure_cover.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【考試向】資料結構筆記（鏈結串列）",
  "url": "https://luketsengtw.github.io/posts/ed071748",
  "image": "https://luketsengtw.github.io/img/data_structure_cover.png",
  "datePublished": "2026-01-08T13:01:07.000Z",
  "dateModified": "2026-01-19T05:01:35.237Z",
  "author": [
    {
      "@type": "Person",
      "name": "LukeTseng",
      "url": "https://luketsengtw.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/website_favicon.ico"><link rel="canonical" href="https://luketsengtw.github.io/posts/ed071748"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="S50ZW5JR-4iAagicR6omYnAz8LUv5ZcouskPpuBaFBs"><link rel="manifest" href="/img/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-7EES35MTFS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-7EES35MTFS"),btf.addGlobalFn("pjaxComplete",()=>{gtag("config","G-7EES35MTFS",{page_path:window.location.pathname})},"google_analytics")</script><script>!function(e,t,a,n,o){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var g=t.getElementsByTagName(a)[0],m=t.createElement(a);m.async=!0,m.src="https://www.googletagmanager.com/gtm.js?id=GTM-5BKRW8SL",g.parentNode.insertBefore(m,g)}(window,document,"script","dataLayer"),btf.addGlobalFn("pjaxComplete",()=>{dataLayer.push({event:"pjaxComplete",page_title:document.title,page_location:location.href,page_path:window.location.pathname})},"google_tag_manager")</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"EF32H7JNEE",apiKey:"876fdde0317458bcae93bc0ded1d7176",indexName:"hexo",hitsPerPage:10,languages:{input_placeholder:"想找些什麼呢...?",hits_empty:"找不到符合您查詢的內容：${query}",hits_stats:"找到 ${hits} 筆結果，耗時 ${time} 毫秒"}},localSearch:void 0,translate:{defaultEncoding:1,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!0,highlightMacStyle:!0},copy:{success:"複製成功",error:"複製失敗",noSupport:"瀏覽器不支援"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"剛剛",min:"分鐘前",hour:"小時前",day:"天前",month:"個月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"已切換為繁體中文",cht_to_chs:"已切換為簡體中文",day_to_night:"已切換為深色模式",night_to_day:"已切換為淺色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"載入更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【考試向】資料結構筆記（鏈結串列）",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Yaoの程式小窩" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><script>(()=>{const e=document.getElementById("loading-box"),d=document.body,t=()=>{e.classList.contains("loaded")||(d.style.overflow="",e.classList.add("loaded"))},o=()=>{d.style.overflow="hidden",e.classList.remove("loaded")};o(),"complete"===document.readyState?t():(window.addEventListener("load",t),document.addEventListener("DOMContentLoaded",t),setTimeout(t,7e3))})()</script><div id="web_bg" style="background-image:url(/img/web_background_smaller.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/data_structure_cover.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/icon.png" alt="Logo"><span class="site-name">Yaoの程式小窩</span></a><a class="nav-page-title" href="/"><span class="site-name">【考試向】資料結構筆記（鏈結串列）</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> 返回首頁</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜尋</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【考試向】資料結構筆記（鏈結串列）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2026-01-08T13:01:07.000Z" title="發表於 2026-01-08 21:01:07">2026-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2026-01-19T05:01:35.237Z" title="更新於 2026-01-19 13:01:35">2026-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/data-structure/">資料結構</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">總字數:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時間:</span><span>31分鐘</span></span><span class="post-meta-separator">|</span><span data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span class="waline-pageview-count" data-path="/posts/ed071748"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">評論數:</span><a href="/posts/ed071748#post-comment"><span class="waline-comment-count" data-path="/posts/ed071748"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>【考試向】資料結構筆記（鏈結串列）</h1><p>歡迎你點入本篇文章！我是 LukeTseng，本系列文章主要整理自學資料結構的一些知識，如果你喜歡我的文章，麻煩您不吝嗇的在文章底下按下一顆愛心，或是追蹤我唷～</p><p>最後更新日期：</p><h2 id="單向鏈結串列（Singly-Linked-list）">單向鏈結串列（Singly Linked list）</h2><p>一般的陣列會在<strong>連續</strong>的記憶體空間中儲存資料。</p><p>鏈結串列可將資料儲存在<strong>不連續</strong>（non-contiguous）的記憶體空間中。</p><p>連續的壞處：</p><ul><li>在中間插入需要將後面的元素各移動一格。</li><li>做刪除操作也要將後面元素往前補上去。</li></ul><p>而在鏈結串列只需要改變指標指向就可以做到插入、刪除的操作。</p><p>在存取元素方面，陣列只需 $O(1)$ ，因為有 index，而鏈結串列需要 $O(n)$ ，因為要從頭一個一個找。</p><h3 id="陣列-v-s-鏈結串列">陣列 v.s. 鏈結串列</h3><table><thead><tr><th></th><th>陣列（Array）</th><th>鏈結串列（Linked-list）</th></tr></thead><tbody><tr><td>記憶體空間</td><td>連續</td><td>不連續</td></tr><tr><td>大小</td><td>固定</td><td>動態</td></tr><tr><td>插入/刪除操作</td><td>慢（要移動後面的所有資料）</td><td>快（只需改變指標指向）</td></tr><tr><td>讀取資料</td><td>$O(1)$</td><td>$O(n)$</td></tr></tbody></table><h3 id="組成的基本要素">組成的基本要素</h3><p>鏈結串列由數個節點（node）組成，一個節點又由以下兩者組成：</p><ul><li>資料（data）</li><li>指標（pointer / next）</li></ul><p>每一個節點都由指標做串聯。</p><p>而節點可以寫成如下程式碼：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Sk5s24Y4Zl.png" alt="singly linked list"></p><p>Image Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.geeksforgeeks.org/dsa/advantages-and-disadvantages-of-linked-list/">Advantages and Disadvantages of Linked List - GeeksforGeeks</a></p><p>圖中的文字解釋：</p><ul><li>Head（頭指標）：指向<strong>第一個</strong>節點的位址，通常這個節點不會放資料。</li><li>Null（空）：<strong>最後一個</strong>節點的指標指向 NULL（或 nullptr），表示後面沒有任何節點，這裡是終點。</li></ul><h3 id="C-程式實作：建立基本鏈結串列">C 程式實作：建立基本鏈結串列</h3><p><code>#include &lt;stdlib.h&gt;</code> 用於 <code>malloc()</code> 以及 <code>free()</code>。</p><p>在大家非常熟悉的 C++ 是用 <code>new</code> 做動態記憶體配置，但在 C 語言裡面呢，用的是 <code>malloc()</code>（英文全名：Memory Allocation）來做配置。</p><p>而 C++ 釋放記憶體用 <code>delete</code>，在 C 就變成 <code>free()</code>。</p><ul><li><code>void *malloc(size_t size);</code><ul><li>回傳新空間第一個位元組的記憶體位址，配置的空間處於尚未初始化的狀態。</li></ul></li><li><code>void free(void *ptr);</code><ul><li>用於釋放先前用 <code>malloc()</code> 配置的記憶體。</li></ul></li></ul><p>以下程式碼有一行 <code>(struct Node*)malloc(sizeof(struct Node));</code>。</p><p>首先看 <code>sizeof(struct Node)</code>，這行主要是要先知道 Node 佔了多少 bytes，知道後給 <code>malloc()</code> 去配置這些 bytes 的記憶體。</p><p><code>(struct Node*)</code> 是顯式型態轉換，因為 <code>malloc()</code> 回傳的型態是 <code>void*</code>，要把他轉成 <code>(struct Node*)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">second</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">third</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || second == <span class="literal">NULL</span> || third == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head -&gt; data = <span class="number">10</span>;</span><br><span class="line">    second -&gt; data = <span class="number">20</span>;</span><br><span class="line">    third -&gt; data = <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    head -&gt; next = second;</span><br><span class="line">    second -&gt; next = third;</span><br><span class="line">    third -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">curr</span> =</span> head; <span class="comment">// 用於讀取跟遍歷用</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Linked list content : &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, curr -&gt; data);</span><br><span class="line">        curr = curr -&gt; next; <span class="comment">// 指向下一個節點</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最後記得釋放記憶體</span></span><br><span class="line">    <span class="comment">// 否則會 leak memory 非常的危險</span></span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="built_in">free</span>(second);</span><br><span class="line">    <span class="built_in">free</span>(third);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作">插入操作</h3><p>預設以下三樣操作的初始圖都長這樣：</p><p><img src="https://hackmd.io/_uploads/ryZk0rKVZx.png" alt="singly linked list initalization"></p><p>三個節點下面那個節點是新節點，準備要插入的。</p><h4 id="插入至最前面">插入至最前面</h4><p>建立了新節點 D 準備插入至最前面。</p><p>讓 D 節點指向 A 節點：</p><p><img src="https://hackmd.io/_uploads/SJmckLY4bg.png" alt="singly linked list join 1"></p><p>接著把 Head 移到 D 上即可：</p><p><img src="https://hackmd.io/_uploads/SJdpkUtEZx.png" alt="singly linked list join 2"></p><h4 id="插入至最後">插入至最後</h4><p>建立了新節點 D 準備插入至最後面，由於是末端，因此 D 需要指向 NULL，如圖：</p><p><img src="https://hackmd.io/_uploads/S1h3eUtN-l.png" alt="singly linked list join 3"></p><p>接著把 C 從原本指向 NULL 改成指向 D：</p><p><img src="https://hackmd.io/_uploads/ByqJ-IFV-l.png" alt="singly linked list join 4"></p><h4 id="插入至某節點後方">插入至某節點後方</h4><p>假設要將新建立的 D 節點插入在 A 節點後方，首先要將 D 節點指向 B：</p><p><img src="https://hackmd.io/_uploads/BJIoZUtNWg.png" alt="singly linked list join 5"></p><p>接著把 A 節點改指向 D：</p><p><img src="https://hackmd.io/_uploads/Skd5MLYEWg.png" alt="singly linked list join 6"></p><p>就完成插入了。</p><h3 id="刪除操作">刪除操作</h3><p>假設接下來的三個操作的初始圖都是：</p><p><img src="https://hackmd.io/_uploads/BJGMQUYEbx.png" alt="singly linked list initialization for delete operation"></p><h4 id="刪除最前面">刪除最前面</h4><p>先用一個臨時指標 <code>temp</code> 指向 A 節點，因為等下 Head 要移走，怕找不到 A 來釋放。</p><p><img src="https://hackmd.io/_uploads/HybF7ItNWg.png" alt="singly linked list delete 1"></p><p>之後將 Head 指向 B 節點：</p><p><img src="https://hackmd.io/_uploads/HkbEBLtNWg.png" alt="singly linked list delete 2"></p><p>最後釋放 temp 指向的記憶體，即可完成。</p><h4 id="刪除尾端">刪除尾端</h4><p>首先用 <code>temp</code> 臨時指標，指向最後一個節點，以便後續做釋放。</p><p><img src="https://hackmd.io/_uploads/r1dsgDK4-x.png" alt="singly linked list delete 3"></p><p>接著在倒數第二個節點 B，改指向 NULL：</p><p><img src="https://hackmd.io/_uploads/HJg0xvtEWl.png" alt="singly linked list delete 4"></p><p>最後釋放掉 temp，即將 C 給刪除了。</p><h4 id="刪除特定節點">刪除特定節點</h4><p>假設要刪除節點 B，一樣先用 <code>temp</code> 臨時指標指向要刪除的節點 B。</p><p><img src="https://hackmd.io/_uploads/SJ34-PF4Zx.png" alt="singly linked list delete 5"></p><p>接著將節點 A 的指標指向節點 C：</p><p><img src="https://hackmd.io/_uploads/Hyw5ZvKEbx.png" alt="singly linked list delete 6"></p><p>最後釋放掉 <code>temp</code>，就會順便把 B 給刪了。</p><h3 id="C-程式實作：插入操作">C 程式實作：插入操作</h3><p>以下程式實作出三種插入操作：插入到最前面、最後面、某節點後面。</p><p>當中 <code>struct Node** head</code> 是為了要修改 <code>head</code> 本身，如果只用一顆星 <code>struct Node* head</code>，傳進去的只是副本，沒有辦法改到函式外的那個 <code>head</code>。</p><p><code>struct Node** head</code> 是把 <code>head</code> 指標的地址傳進去，讓函式可以直接修改外面的 <code>head</code> 變數。</p><p><code>struct Node* createNode(int data)</code> 是為了把建立節點麻煩的步驟包裝成一個函式，以便後續操作。</p><p>注意到 <code>push_front(&amp;head, data)</code> 跟 <code>push_back(&amp;head, data)</code> 這兩個都用 <code>head</code> 的位址傳進去。</p><p>如果不傳位址進去，函式裡面的 <code>head</code> 換成了新節點，但 main 函式裡的 <code>head</code> 還指著舊的 <code>head</code>。</p><p>而 <code>push_back(&amp;head, data)</code> 的考量是假設鏈結串列是空的（<code>NULL</code>），此時頭尾都一樣，需要修改到 <code>head</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode -&gt; data = data;</span><br><span class="line">    newNode -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="keyword">struct</span> Node** head_ref, <span class="type">int</span> new_data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">new_node</span> =</span> createNode(new_data);</span><br><span class="line">    new_node -&gt; next = (*head_ref);</span><br><span class="line">    (*head_ref) = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(<span class="keyword">struct</span> Node** head_ref, <span class="type">int</span> new_data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">new_node</span> =</span> createNode(new_data);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *head_ref = new_node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">last</span> =</span> *head_ref;</span><br><span class="line">    <span class="keyword">while</span> (last-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    last-&gt;next = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_after</span><span class="params">(<span class="keyword">struct</span> Node* prev_node, <span class="type">int</span> new_data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prev_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : 指定的前一個節點是 NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">new_node</span> =</span> createNode(new_data);</span><br><span class="line">    </span><br><span class="line">    new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">    prev_node-&gt;next = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node* node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    push_back(&amp;head, <span class="number">10</span>);</span><br><span class="line">    printList(head);</span><br><span class="line">    </span><br><span class="line">    push_back(&amp;head, <span class="number">20</span>);</span><br><span class="line">    printList(head);</span><br><span class="line">    </span><br><span class="line">    push_front(&amp;head, <span class="number">5</span>);</span><br><span class="line">    printList(head);</span><br><span class="line">    </span><br><span class="line">    insert_after(head-&gt;next, <span class="number">15</span>);</span><br><span class="line">    printList(head);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 -&gt; NULL</span><br><span class="line">10 -&gt; 20 -&gt; NULL</span><br><span class="line">5 -&gt; 10 -&gt; 20 -&gt; NULL</span><br><span class="line">5 -&gt; 10 -&gt; 15 -&gt; 20 -&gt; NULL</span><br></pre></td></tr></table></figure><p>三種插入操作時間複雜度：</p><ol><li>插入至最前面： $O(1)$</li><li>插入至最後面： $O(n)$（無尾指標，需慢慢找） / $O(1)$（有尾指標）</li><li>插入至特定節點後方： $O(1)$ （已知節點） / $O(n)$ （未知節點，要先找）</li></ol><h3 id="C-程式實作：刪除操作">C 程式實作：刪除操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode -&gt; data = data;</span><br><span class="line">    newNode -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_front</span><span class="params">(<span class="keyword">struct</span> Node** head_ref)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;串列為空，無法刪除\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> *head_ref;</span><br><span class="line">    </span><br><span class="line">    *head_ref = (*head_ref) -&gt; next;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_back</span><span class="params">(<span class="keyword">struct</span> Node** head_ref)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;串列為空，無法刪除\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假設只有一個節點</span></span><br><span class="line">    <span class="keyword">if</span> ((*head_ref)-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(*head_ref);</span><br><span class="line">        *head_ref = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尋找倒數第二個節點</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">second_last</span> =</span> *head_ref;</span><br><span class="line">    <span class="keyword">while</span> (second_last-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        second_last = second_last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(second_last-&gt;next); <span class="comment">// 釋放倒數第二節點的下一個</span></span><br><span class="line">    second_last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="keyword">struct</span> Node** head_ref, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> *head_ref;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;data == key)&#123;</span><br><span class="line">        *head_ref = temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;data != key) &#123;</span><br><span class="line">        prev = temp;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找不到數值 %d，刪除失敗\n&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    prev-&gt;next = temp-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node* node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    head = createNode(<span class="number">10</span>);</span><br><span class="line">    head-&gt;next = createNode(<span class="number">20</span>);</span><br><span class="line">    head-&gt;next-&gt;next = createNode(<span class="number">30</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next = createNode(<span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    delete_front(&amp;head);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    delete_back(&amp;head);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    delete_node(&amp;head, <span class="number">20</span>); </span><br><span class="line">    printList(head);</span><br><span class="line">    </span><br><span class="line">    delete_node(&amp;head, <span class="number">99</span>);</span><br><span class="line">    </span><br><span class="line">    delete_node(&amp;head, <span class="number">30</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 -&gt; 20 -&gt; 30 -&gt; 40 -&gt; NULL</span><br><span class="line">20 -&gt; 30 -&gt; 40 -&gt; NULL</span><br><span class="line">20 -&gt; 30 -&gt; NULL</span><br><span class="line">30 -&gt; NULL</span><br><span class="line">找不到數值 99，刪除失敗</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><p>三種刪除操作時間複雜度：</p><ul><li>刪除最前面： $O(1)$</li><li>刪除最後面： $O(n)$ （需尋找尾端）</li><li>刪除指定節點： $O(n)$ （需尋找欲刪除節點的前一個節點） / $O(1)$ （已知欲刪除節點的前一個節點）</li></ul><h3 id="兩單向鏈結串列串接">兩單向鏈結串列串接</h3><p>假設兩串列 A, B 長以下圖那樣：</p><p><img src="https://hackmd.io/_uploads/S12aQPo4We.png" alt="singly linked list concatenate 1"></p><p>想要做 A + B 的串接的話，只需要將 A 的最後一個節點指向 B 的開頭即可。</p><p><img src="https://hackmd.io/_uploads/ryv44DsVWx.png" alt="singly linked list concatenate 2"></p><h3 id="C-程式實作：兩單向鏈結串列串接">C 程式實作：兩單向鏈結串列串接</h3><p>需要考慮 Edge Case（特殊情況）：</p><ol><li>List A 是空的（NULL）：直接把 Head A 指向 Head B。</li><li>List B 是空的（NULL）：什麼都不用做。</li></ol><p>串接操作：從 List A 的頭開始走，走到尾端後，把 A 的 .next 指向 B 的開頭即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode -&gt; data = data;</span><br><span class="line">    newNode -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">concatenate</span><span class="params">(<span class="keyword">struct</span> Node** headA_ref, <span class="keyword">struct</span> Node* headB)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*headA_ref == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *headA_ref = headB;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (headB == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">curr</span> =</span> *headA_ref;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (curr -&gt; next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        curr = curr -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    curr-&gt;next = headB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node* node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">headA</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">headB</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    headA = createNode(<span class="number">10</span>);</span><br><span class="line">    headA-&gt;next = createNode(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    headB = createNode(<span class="number">30</span>);</span><br><span class="line">    headB-&gt;next = createNode(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;串接前 List A: &quot;</span>);</span><br><span class="line">    printList(headA);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;串接前 List B: &quot;</span>);</span><br><span class="line">    printList(headB);</span><br><span class="line"></span><br><span class="line">    concatenate(&amp;headA, headB);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;串接後 List A: &quot;</span>);</span><br><span class="line">    printList(headA);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">串接前 List A: 10 -&gt; 20 -&gt; NULL</span><br><span class="line">串接前 List B: 30 -&gt; 40 -&gt; NULL</span><br><span class="line">-----------------</span><br><span class="line">串接後 List A: 10 -&gt; 20 -&gt; 30 -&gt; 40 -&gt; NULL</span><br></pre></td></tr></table></figure><p>時間複雜度： $O(n)$ （需尋找 A 串列的尾端）</p><h3 id="反轉單向鏈結串列：三指標法">反轉單向鏈結串列：三指標法</h3><p>需用到三個變數，可稱其為三指標：</p><ul><li><code>curr</code>：表示當前節點。</li><li><code>prev</code>：表示前一個節點。</li><li><code>next</code>：表示下一個節點。</li></ul><p>反轉原理：假設串列是：<code>10 -&gt; 20 -&gt; 30 -&gt; NULL</code>，以第一輪迴圈 10 開始。</p><ol><li>做備份：用 <code>next</code> 記住 <code>20</code> 的位置。</li><li>反轉：用 <code>10</code> 的 <code>next</code> 指向 <code>prev</code>（<code>NULL</code>），此時 <code>10 -&gt; NULL</code>。</li><li>前進：將所有節點往後一格，此時 <code>prev = 10</code>, <code>curr = 20</code>。</li></ol><p>接著以此類推。</p><h3 id="C-程式實作：反轉單向鏈結串列">C 程式實作：反轉單向鏈結串列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode -&gt; data = data;</span><br><span class="line">    newNode -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="keyword">struct</span> Node** head_ref)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">curr</span> =</span> *head_ref;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        </span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *head_ref = prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node* node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    head = createNode(<span class="number">10</span>);</span><br><span class="line">    head-&gt;next = createNode(<span class="number">20</span>);</span><br><span class="line">    head-&gt;next-&gt;next = createNode(<span class="number">30</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next = createNode(<span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原串列:\n&quot;</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    reverse(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;反轉後的串列:\n&quot;</span>);</span><br><span class="line">    printList(head);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>時間複雜度： $O(n)$</p><h2 id="雙向鏈結串列（Doubly-Linked-List）">雙向鏈結串列（Doubly Linked List）</h2><p>與單向鏈結串列的差別是，單向只能往前走，不能往後走，而雙向可以在任意節點選擇要往前還是往後，如圖：</p><p><img src="https://hackmd.io/_uploads/HJACHdoVZe.png" alt="Doubly Linked List"></p><p>Image Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.geeksforgeeks.org/dsa/doubly-linked-list-tutorial/">Operations of Doubly Linked List with Implementation - GeeksforGeeks</a></p><p>在原有的基礎下，雙向鏈結串列的一個節點需要存以下這三個變數：</p><ul><li><code>prev</code>（也稱 <code>llink</code> 左鏈結）：指向前一個節點的位址。</li><li><code>data</code>：存放資料。</li><li><code>next</code>（也稱 <code>rlink</code> 右鏈結）：指向下一個節點的位址。</li></ul><h3 id="C-程式實作：雙向鏈結串列定義">C 程式實作：雙向鏈結串列定義</h3><p>註：僅片段程式碼，展示 <code>struct</code> 定義及 <code>createNode</code> 函數包裝。</p><p>在單向鏈結串列原有基礎下，新增 <code>struct Node* prev</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    </span><br><span class="line">    newNode -&gt; data = data;</span><br><span class="line">    </span><br><span class="line">    newNode -&gt; prev = <span class="literal">NULL</span>;</span><br><span class="line">    newNode -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作-2">插入操作</h3><p>需注意先後順序，文中敘述先講的操作如 <code>next</code> 要指向誰等等，就先會做。</p><h4 id="插入至最前端">插入至最前端</h4><p>假設有一新節點 D 想要插入到最前面，則將其 <code>next</code> 指標指向節點 A，<code>prev</code> 指向 <code>NULL</code>。</p><p><img src="https://hackmd.io/_uploads/S1YHjJnVZx.png" alt="image"></p><p>這樣就換頭成功。</p><h4 id="插入至最尾端">插入至最尾端</h4><p>假設有一新節點 D 想要插入到最後面，則將其 <code>next</code> 指標指向 <code>NULL</code>，<code>prev</code> 指向原本最後面的節點 C。</p><p>節點 C 要從指向 <code>NULL</code> 改指向 D。</p><p><img src="https://hackmd.io/_uploads/Bypxhk34Zg.png" alt="image"></p><h4 id="插入至特定節點">插入至特定節點</h4><p>假設有一新節點 D 想要插入在節點 B 的後方。</p><p>節點 D 需要將 <code>next</code> 指向 B 的下一個節點 C，<code>prev</code> 指向 B 節點。</p><p>接著節點 C 的 <code>prev</code> 指向 D。</p><p>最後節點 B 的 <code>next</code> 指向 D。</p><p><img src="https://hackmd.io/_uploads/BktmCJ2Nbl.png" alt="image"></p><h3 id="刪除操作-2">刪除操作</h3><p>懶得畫圖了…</p><h4 id="刪除最前面-2">刪除最前面</h4><p>要刪除最前面的節點，則先將 Head 改指向其後方的節點。</p><p>接著把新的 Head 的 <code>prev</code> 改指向 <code>NULL</code>，因為原本還是指向舊的 Head。</p><p><img src="https://hackmd.io/_uploads/S1X-ee24Zl.png" alt="image"></p><p>Image Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.geeksforgeeks.org/dsa/delete-a-node-in-a-doubly-linked-list/">Deletion in a Doubly Linked List - GeeksforGeeks</a></p><h4 id="刪除最後面">刪除最後面</h4><p>首先找出倒數第二個節點。</p><p>把倒數第二個節點的 <code>next</code> 改指向 <code>NULL</code>，即可刪除最後一個節點。</p><p><img src="https://hackmd.io/_uploads/HJ_clgnVZx.png" alt="image"></p><p>Image Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.geeksforgeeks.org/dsa/delete-a-node-in-a-doubly-linked-list/">Deletion in a Doubly Linked List - GeeksforGeeks</a></p><h4 id="刪除特定節點-2">刪除特定節點</h4><p>先看到第一個節點，將其 <code>next</code> 指向最後一個節點。</p><p>接著最後一個節點的 <code>prev</code> 指向第一個節點。</p><p>就可以刪掉中間那個節點了。</p><p><img src="https://hackmd.io/_uploads/S1YMbg3Ebe.png" alt="image"></p><p>Image Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.geeksforgeeks.org/dsa/delete-a-node-in-a-doubly-linked-list/">Deletion in a Doubly Linked List - GeeksforGeeks</a></p><h3 id="C-程式實作：插入操作-2">C 程式實作：插入操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    </span><br><span class="line">    newNode -&gt; data = data;</span><br><span class="line">    </span><br><span class="line">    newNode -&gt; prev = <span class="literal">NULL</span>;</span><br><span class="line">    newNode -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="keyword">struct</span> Node** head_ref, <span class="type">int</span> new_data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">new_node</span> =</span> createNode(new_data);</span><br><span class="line">    </span><br><span class="line">    new_node -&gt; next = (*head_ref);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判斷舊 head 是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((*head_ref) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        (*head_ref)-&gt;prev = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    (*head_ref) = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(<span class="keyword">struct</span> Node** head_ref, <span class="type">int</span> new_data)</span>&#123;</span><br><span class="line">    <span class="comment">// 由於 new_node 的 next 預設是 NULL</span></span><br><span class="line">    <span class="comment">// 所以不用特地寫 new_node -&gt; next = NULL;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">new_node</span> =</span> createNode(new_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若串列為空</span></span><br><span class="line">    <span class="comment">// 則新節點即為 head</span></span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *head_ref = new_node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尋找最後一個節點</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">last</span> =</span> *head_ref;</span><br><span class="line">    <span class="keyword">while</span> (last-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    last-&gt;next = new_node;</span><br><span class="line">    </span><br><span class="line">    new_node-&gt;prev = last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_after</span><span class="params">(<span class="keyword">struct</span> Node* prev_node, <span class="type">int</span> new_data)</span>&#123;</span><br><span class="line">    <span class="comment">// 檢驗前一個節點是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (prev_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : 指定的前一個節點是 NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">new_node</span> =</span> createNode(new_data);</span><br><span class="line">    </span><br><span class="line">    new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">    new_node-&gt;prev = prev_node;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (new_node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        new_node-&gt;next-&gt;prev = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    prev_node-&gt;next = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node* node)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">last</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正向走訪: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        last = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;反向走訪: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (last != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, last-&gt;data);</span><br><span class="line">        last = last-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    push_back(&amp;head, <span class="number">10</span>);</span><br><span class="line">    push_back(&amp;head, <span class="number">20</span>);</span><br><span class="line">    push_back(&amp;head, <span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">    push_front(&amp;head, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    insert_after(head-&gt;next, <span class="number">15</span>);</span><br><span class="line">    </span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正向走訪: 5 -&gt; 10 -&gt; 15 -&gt; 20 -&gt; 30 -&gt; NULL</span><br><span class="line">反向走訪: 30 -&gt; 20 -&gt; 15 -&gt; 10 -&gt; 5 -&gt; NULL</span><br><span class="line">--------------------------</span><br></pre></td></tr></table></figure><p>時間複雜度：</p><ul><li>插入至最前面： $O(1)$</li><li>插入至最後面： $O(n)$</li><li>插入至特定節點後方： $O(1)$ （已知該節點）</li></ul><h3 id="C-程式實作：刪除操作-2">C 程式實作：刪除操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    </span><br><span class="line">    newNode -&gt; data = data;</span><br><span class="line">    </span><br><span class="line">    newNode -&gt; prev = <span class="literal">NULL</span>;</span><br><span class="line">    newNode -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_front</span><span class="params">(<span class="keyword">struct</span> Node** head_ref)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;串列為空無法刪除\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> *head_ref;</span><br><span class="line">    </span><br><span class="line">    *head_ref = temp -&gt; next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*head_ref != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        (*head_ref) -&gt; prev = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_end</span><span class="params">(<span class="keyword">struct</span> Node** head_ref)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;串列為空無法刪除\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">last</span> =</span> *head_ref;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (last-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *head_ref = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(last);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已刪除尾部節點 (原串列僅剩一個)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (last-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        last = last -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    last -&gt; prev -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="keyword">struct</span> Node** head_ref, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">curr</span> =</span> *head_ref;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span> &amp;&amp; curr -&gt; data != key)&#123;</span><br><span class="line">        curr = curr -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : 找不到數值 %d\n&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*head_ref == curr)&#123;</span><br><span class="line">        *head_ref = curr -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curr -&gt; prev != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        curr -&gt; prev -&gt; next = curr -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curr -&gt; next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        curr -&gt; next -&gt; prev = curr -&gt; prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(curr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node* node)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">last</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正向走訪: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        last = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;反向走訪: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (last != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, last-&gt;data);</span><br><span class="line">        last = last-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立測試資料 10 &lt;-&gt; 20 &lt;-&gt; 30 &lt;-&gt; 40 &lt;-&gt; 50</span></span><br><span class="line">    head = createNode(<span class="number">10</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">n2</span> =</span> createNode(<span class="number">20</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">n3</span> =</span> createNode(<span class="number">30</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">n4</span> =</span> createNode(<span class="number">40</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">n5</span> =</span> createNode(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手動串接</span></span><br><span class="line">    head-&gt;next = n2; n2-&gt;prev = head;</span><br><span class="line">    n2-&gt;next = n3;   n3-&gt;prev = n2;</span><br><span class="line">    n3-&gt;next = n4;   n4-&gt;prev = n3;</span><br><span class="line">    n4-&gt;next = n5;   n5-&gt;prev = n4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始狀態：\n&quot;</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    delete_front(&amp;head);</span><br><span class="line">    printList(head); </span><br><span class="line"></span><br><span class="line">    delete_end(&amp;head);</span><br><span class="line">    printList(head); </span><br><span class="line">    </span><br><span class="line">    delete_node(&amp;head, <span class="number">30</span>);</span><br><span class="line">    printList(head); </span><br><span class="line"></span><br><span class="line">    delete_node(&amp;head, <span class="number">20</span>);</span><br><span class="line">    delete_node(&amp;head, <span class="number">40</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">初始狀態：</span><br><span class="line">正向走訪: 10 -&gt; 20 -&gt; 30 -&gt; 40 -&gt; 50 -&gt; NULL</span><br><span class="line">反向走訪: 50 -&gt; 40 -&gt; 30 -&gt; 20 -&gt; 10 -&gt; NULL</span><br><span class="line">--------------------------</span><br><span class="line">正向走訪: 20 -&gt; 30 -&gt; 40 -&gt; 50 -&gt; NULL</span><br><span class="line">反向走訪: 50 -&gt; 40 -&gt; 30 -&gt; 20 -&gt; NULL</span><br><span class="line">--------------------------</span><br><span class="line">正向走訪: 20 -&gt; 30 -&gt; 40 -&gt; NULL</span><br><span class="line">反向走訪: 40 -&gt; 30 -&gt; 20 -&gt; NULL</span><br><span class="line">--------------------------</span><br><span class="line">正向走訪: 20 -&gt; 40 -&gt; NULL</span><br><span class="line">反向走訪: 40 -&gt; 20 -&gt; NULL</span><br><span class="line">--------------------------</span><br><span class="line">正向走訪: NULL</span><br><span class="line">反向走訪: NULL</span><br><span class="line">--------------------------</span><br></pre></td></tr></table></figure><p>三種刪除操作時間複雜度：</p><ul><li>刪除最前面：$O(1)$</li><li>刪除尾端：$O(n)$</li><li>刪除特定節點：$O(1)$ / $O(n)$</li></ul><h2 id="環狀鏈結串列（Circular-Linked-List）">環狀鏈結串列（Circular Linked List）</h2><p>與一般單向鏈結串列（Singly Linked list）不同的是，環狀鏈結串列是沒有終點的（最後一個節點<strong>不</strong>指向 NULL），最後一個節點會指向回到第一個節點，形成一個閉環，如圖：</p><p><img src="https://hackmd.io/_uploads/SyAz7doVWx.png" alt="Circular Linked List"></p><p>Image Source：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.geeksforgeeks.org/java/circular-linked-list-java/">Circular Linked List Implementation in Java - GeeksforGeeks</a></p><h3 id="組成的基本要素-2">組成的基本要素</h3><ul><li>首尾相連：最後一個節點的 <code>next</code> 指標指向 <code>Head</code>（頭節點）。</li><li>無 <code>NULL</code> 指標：只要串列不為空，整個串列中不會有任何節點指向 <code>NULL</code>。</li></ul><h3 id="類型">類型</h3><ul><li>單向環狀鏈結串列（Circular Singly Linked List）：每個節點只有一個 <code>next</code> 指標，單向繞圈。</li><li>雙向環狀鏈結串列（Circular Doubly Linked List）：每個節點有 <code>next</code> 和 <code>prev</code>。最後一個節點的 <code>next</code> 指向頭，頭節點的 <code>prev</code> 指向最後一個節點。</li></ul><h3 id="C-程式實作：單向環狀鏈結串列">C 程式實作：單向環狀鏈結串列</h3><p>以下程式在單向環狀鏈結串列中展示了以下這些操作：</p><ul><li>插入至最前面</li><li>插入至最後面</li><li>刪除特定節點</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    </span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(<span class="keyword">struct</span> Node** head_ref, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> createNode(data);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">last</span> =</span> *head_ref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串列為空</span></span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *head_ref = newNode;</span><br><span class="line">        newNode-&gt;next = *head_ref; <span class="comment">// 自己指回自己</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串列不為空</span></span><br><span class="line">    <span class="comment">// 先找到最後一個節點</span></span><br><span class="line">    <span class="keyword">while</span> (last-&gt;next != *head_ref) &#123;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 調整指標</span></span><br><span class="line">    last-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;next = *head_ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="keyword">struct</span> Node** head_ref, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> createNode(data);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">last</span> =</span> *head_ref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串列為空</span></span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *head_ref = newNode;</span><br><span class="line">        newNode-&gt;next = *head_ref;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找最後一個節點</span></span><br><span class="line">    <span class="keyword">while</span> (last-&gt;next != *head_ref) &#123;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 調整指標</span></span><br><span class="line">    newNode-&gt;next = *head_ref; <span class="comment">// 新節點指向舊頭</span></span><br><span class="line">    last-&gt;next = newNode;      <span class="comment">// 最後節點指向新節點</span></span><br><span class="line">    *head_ref = newNode;       <span class="comment">// 更新頭指標指向新節點</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> Node** head_ref, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">curr</span> =</span> *head_ref, *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要刪除的是頭節點</span></span><br><span class="line">    <span class="keyword">if</span> (curr-&gt;data == key) &#123;</span><br><span class="line">        <span class="comment">// 串列中只有這一個節點</span></span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;next == *head_ref) &#123;</span><br><span class="line">            *head_ref = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 串列有多個節點</span></span><br><span class="line">        <span class="comment">// 需先找到最後一個節點來更新鏈結</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">struct</span> Node* last = *head_ref;</span><br><span class="line">            <span class="keyword">while</span> (last-&gt;next != *head_ref) &#123;</span><br><span class="line">                last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最後節點指向新的頭 (head-&gt;next)</span></span><br><span class="line">            last-&gt;next = curr-&gt;next;</span><br><span class="line">            *head_ref = curr-&gt;next; <span class="comment">// 移動 head 指標</span></span><br><span class="line">            <span class="built_in">free</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要刪除的不是頭節點，遍歷尋找</span></span><br><span class="line">    <span class="comment">// 用 while 檢查是否繞回起點</span></span><br><span class="line">    <span class="keyword">while</span> (curr-&gt;next != *head_ref &amp;&amp; curr-&gt;data != key) &#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 檢查是否找到了該節點</span></span><br><span class="line">    <span class="keyword">if</span> (curr-&gt;data == key) &#123;</span><br><span class="line">        prev-&gt;next = curr-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(curr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;數值 %d 不在串列中。\n&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">current</span> =</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;串列為空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;環狀串列內容: &quot;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(回到 head: %d)\n&quot;</span>, head-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    push_back(&amp;head, <span class="number">10</span>);</span><br><span class="line">    push_back(&amp;head, <span class="number">20</span>);</span><br><span class="line">    push_back(&amp;head, <span class="number">30</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    push_front(&amp;head, <span class="number">5</span>);</span><br><span class="line">    printList(head);</span><br><span class="line">    </span><br><span class="line">    deleteNode(&amp;head, <span class="number">5</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    deleteNode(&amp;head, <span class="number">20</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    deleteNode(&amp;head, <span class="number">10</span>);</span><br><span class="line">    deleteNode(&amp;head, <span class="number">30</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">環狀串列內容: 10 -&gt; 20 -&gt; 30 -&gt; (回到 head: 10)</span><br><span class="line">環狀串列內容: 5 -&gt; 10 -&gt; 20 -&gt; 30 -&gt; (回到 head: 5)</span><br><span class="line">環狀串列內容: 10 -&gt; 20 -&gt; 30 -&gt; (回到 head: 10)</span><br><span class="line">環狀串列內容: 10 -&gt; 30 -&gt; (回到 head: 10)</span><br><span class="line">串列為空</span><br></pre></td></tr></table></figure><p>時間複雜度：</p><ul><li>插入至最後面： $O(n)$</li><li>插入至最前面： $O(n)$</li><li>刪除特定節點： $O(n)$</li></ul><h2 id="鏈結串列的應用">鏈結串列的應用</h2><h3 id="用鏈結串列表示堆疊（Stack）">用鏈結串列表示堆疊（Stack）</h3><p>以單向鏈結串列實作，選擇將 Head 端當作 stack 的 top，若用尾端作為 top，時間複雜度會提升。</p><ul><li>在 Head 操作： 插入和刪除節點只需要修改指標，時間複雜度為 $O(1)$ 。</li><li>在尾端操作：插入容易，但刪除（pop）時需要遍歷整個串列找到「倒數第二個節點」才能將其指向 Null，時間複雜度為 $O(n)$。</li></ul><h4 id="Push-操作">Push 操作</h4><p>將新資料放入堆疊頂端。</p><ol><li>建立一個新節點 <code>newNode</code>。</li><li>將 <code>newNode</code> 的 <code>next</code> 指標指向目前的 <code>top</code>。</li><li>將 <code>top</code> 指標更新，使其指向 <code>newNode</code>。</li><li>最後新節點成為了新的 <code>top</code>。</li></ol><h4 id="Pop-操作">Pop 操作</h4><p>將堆疊頂端的資料移除並回傳。</p><ol><li>檢查堆疊是否為空（<code>top == NULL</code>）。</li><li>暫存目前的 <code>top</code> 節點到 <code>temp</code>（為了釋放記憶體）。</li><li>將 <code>top</code> 指標往後移動（<code>top = top-&gt;next</code>）。</li><li>刪除 <code>temp</code> 節點（釋放記憶體）。</li><li>最後原第二個節點變成了新的 <code>top</code>。</li></ol><h4 id="存取頂端（peek）">存取頂端（peek）</h4><p>直接回傳 <code>top</code> 節點的資料即可：<code>top -&gt; data</code>。</p><h3 id="C-程式實作：以鏈結串列實現堆疊">C 程式實作：以鏈結串列實現堆疊</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    Node* top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    s-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* s, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;記憶體配置失敗！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = val;</span><br><span class="line">    newNode-&gt;next = s-&gt;top; <span class="comment">// 新節點指向舊的 Top</span></span><br><span class="line">    s-&gt;top = newNode; <span class="comment">// 更新堆疊的 Top 為新節點</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pushed: %d\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack Underflow! (堆疊已空)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* temp = s-&gt;top; <span class="comment">// 暫存目前的 Top 節點</span></span><br><span class="line">    s-&gt;top = s-&gt;top-&gt;next; <span class="comment">// 將 Top 指標往下移</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Stack myStack;</span><br><span class="line">    initStack(&amp;myStack); <span class="comment">// 傳址 &amp; 才可以改到 myStack</span></span><br><span class="line"></span><br><span class="line">    push(&amp;myStack, <span class="number">10</span>);</span><br><span class="line">    push(&amp;myStack, <span class="number">20</span>);</span><br><span class="line">    push(&amp;myStack, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;目前的 top 是: %d\n&quot;</span>, peek(&amp;myStack));</span><br><span class="line"></span><br><span class="line">    pop(&amp;myStack); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pop 之後的 top 是: %d\n&quot;</span>, peek(&amp;myStack));</span><br><span class="line"></span><br><span class="line">    pop(&amp;myStack);</span><br><span class="line">    pop(&amp;myStack);</span><br><span class="line">    pop(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用鏈結串列表示佇列（Queue）">用鏈結串列表示佇列（Queue）</h3><p>佇列的 Front 對應 Head，Rear 對應 Tail（鏈結串列尾端）。</p><p>Head 端用於刪除資料，Tail 端用於插入資料。</p><h4 id="enqueue-操作">enqueue 操作</h4><p>將資料加入佇列尾端。</p><ol><li>建立新節點 <code>newNode</code>。</li><li>檢查佇列是否為空：<ul><li>是：<code>front</code> 和 <code>rear</code> 都指向 <code>newNode</code>。</li><li>否：<ul><li>將目前 <code>rear</code> 的 <code>next</code> 指向 <code>newNode</code>。</li><li>更新 <code>rear</code> 指標指向 <code>newNode</code>。</li></ul></li></ul></li></ol><h4 id="dequeue-操作">dequeue 操作</h4><p>將佇列頭端的資料移除。</p><ol><li>檢查佇列是否為空（<code>front == NULL</code>）。</li><li>暫存目前的 <code>front</code> 到 <code>temp</code>。</li><li>將 <code>front</code> 往後移（<code>front = front-&gt;next</code>）。</li><li>如果移完之後 <code>front = NULL</code>（代表剛刪掉的是最後一個節點），則必須把 <code>rear = NULL</code>，否則 <code>rear</code> 會變成懸空指標（Dangling Pointer）。</li><li>釋放 <code>temp</code> 記憶體。</li></ol><h3 id="C-程式實作：以鏈結串列實現佇列">C 程式實作：以鏈結串列實現佇列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    Node* front;</span><br><span class="line">    Node* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 將元素插入至尾端</span></span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 記憶體不足</span></span><br><span class="line">    </span><br><span class="line">    newNode-&gt;data = val;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">// newNode 為最後一個節點</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果佇列為空</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;front = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 佇列不為空</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enqueued: %d\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue Underflow! (佇列已空)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* temp = q-&gt;front;</span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next; <span class="comment">// 頭指標往後移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果佇列變空了，rear 也要歸零</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dequeued: %d\n&quot;</span>, temp-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue myQueue;</span><br><span class="line">    initQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue, <span class="number">10</span>);</span><br><span class="line">    enqueue(&amp;myQueue, <span class="number">20</span>);</span><br><span class="line">    enqueue(&amp;myQueue, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    dequeue(&amp;myQueue);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Front element: %d\n&quot;</span>, peek(&amp;myQueue));</span><br><span class="line">    </span><br><span class="line">    dequeue(&amp;myQueue);</span><br><span class="line">    dequeue(&amp;myQueue);</span><br><span class="line">    dequeue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="總整理">總整理</h2><h3 id="陣列-v-s-鏈結串列-2">陣列 v.s. 鏈結串列</h3><ul><li>陣列（Array）<ul><li>記憶體連續。</li><li>隨機存取快： $O(1)$ 。</li><li>插入、刪除慢：需搬移資料。</li></ul></li><li>鏈結串列（Linked List）<ul><li>記憶體不連續。</li><li>插入、刪除快：只改指標。</li><li>存取慢：需逐節點走訪 $O(n)$ 。</li></ul></li></ul><p>陣列靠 index，鏈結串列靠指標。</p><h3 id="單向鏈結串列（Singly-Linked-List）">單向鏈結串列（Singly Linked List）</h3><h4 id="結構">結構</h4><p>節點包含：</p><ul><li>data</li><li>next</li></ul><p>最後一個節點 <code>next = NULL</code>。</p><h4 id="常見操作與時間複雜度">常見操作與時間複雜度</h4><p><strong>插入</strong></p><table><thead><tr><th>操作</th><th>時間複雜度</th></tr></thead><tbody><tr><td>插入最前面</td><td>$O(1)$</td></tr><tr><td>插入最後面</td><td>$O(n)$（無尾指標）／ $O(1)$（有尾指標）</td></tr><tr><td>插入特定節點後</td><td>$O(1)$（已知節點）／ $O(n)$（需先找）</td></tr></tbody></table><p><strong>刪除</strong></p><table><thead><tr><th>操作</th><th>時間複雜度</th></tr></thead><tbody><tr><td>刪除最前面</td><td>$O(1)$</td></tr><tr><td>刪除最後面</td><td>$O(n)$</td></tr><tr><td>刪除指定節點</td><td>$O(n)$ ／ $O(1)$（已知前一節點）</td></tr></tbody></table><h3 id="反轉單向鏈結串列（Three-Pointer-Method）">反轉單向鏈結串列（Three-Pointer Method）</h3><p>使用三個指標：</p><ul><li>prev</li><li>curr</li><li>next</li></ul><p>每次只做三件事：</p><ul><li>記住下一個。</li><li>反轉指向。</li><li>指標前進。</li></ul><p>時間複雜度： $O(n)$</p><p>空間複雜度： $O(1)$</p><h3 id="雙向鏈結串列（Doubly-Linked-List）-2">雙向鏈結串列（Doubly Linked List）</h3><h4 id="結構-2">結構</h4><p>節點包含：</p><ul><li>prev</li><li>data</li><li>next</li></ul><h4 id="特點">特點</h4><ul><li>可前後走訪。</li><li>插入、刪除更直覺。</li><li>記憶體成本較高（多一個指標）。</li></ul><h4 id="常見操作與時間複雜度-2">常見操作與時間複雜度</h4><p><strong>插入</strong></p><table><thead><tr><th>操作</th><th>時間複雜度</th></tr></thead><tbody><tr><td>插入最前面</td><td>$O(1)$</td></tr><tr><td>插入最後面</td><td>$O(n)$</td></tr><tr><td>插入特定節點</td><td>$O(1)$</td></tr></tbody></table><p><strong>刪除</strong></p><table><thead><tr><th>操作</th><th>時間複雜度</th></tr></thead><tbody><tr><td>刪除最前面</td><td>$O(1)$</td></tr><tr><td>刪除最後面</td><td>$O(n)$</td></tr><tr><td>刪除特定節點</td><td>$O(1)$ ／ $O(n)$</td></tr></tbody></table><h3 id="環狀鏈結串列（Circular-Linked-List）-2">環狀鏈結串列（Circular Linked List）</h3><h4 id="特性">特性</h4><ul><li>沒有 NULL</li><li>尾節點 next 指回 head</li><li>可無限循環</li></ul><h4 id="類型-2">類型</h4><ul><li>單向環狀</li><li>雙向環狀</li></ul><h4 id="時間複雜度（單向環狀）">時間複雜度（單向環狀）</h4><table><thead><tr><th>操作</th><th>時間複雜度</th></tr></thead><tbody><tr><td>插入最前</td><td>$O(n)$</td></tr><tr><td>插入最後</td><td>$O(n)$</td></tr><tr><td>刪除指定節點</td><td>$O(n)$</td></tr></tbody></table><p>搭配尾指標，插入可優化至 $O(1)$ 。</p><h3 id="鏈結串列的實際應用">鏈結串列的實際應用</h3><h4 id="以鏈結串列實作堆疊（Stack）">以鏈結串列實作堆疊（Stack）</h4><ul><li><code>top</code> 設在 <code>Head</code>。</li><li><code>Push</code> / <code>Pop</code> 都是 $O(1)$。</li></ul><table><thead><tr><th>操作</th><th>對應行為</th></tr></thead><tbody><tr><td>push</td><td>插入至 Head</td></tr><tr><td>pop</td><td>刪除 Head</td></tr><tr><td>peek</td><td>讀取 Head</td></tr></tbody></table><p>若用尾端當 <code>top</code>，<code>pop</code> 會退化成 $O(n)$。</p><h4 id="以鏈結串列實作佇列（Queue）">以鏈結串列實作佇列（Queue）</h4><ul><li>Head → Front（刪除）</li><li>Tail → Rear（插入）</li></ul><table><thead><tr><th>操作</th><th>時間複雜度</th></tr></thead><tbody><tr><td>Enqueue</td><td><code>O(1)</code></td></tr><tr><td>Dequeue</td><td><code>O(1)</code></td></tr></tbody></table><p>刪除最後一個節點時，rear 必須設為 NULL，避免懸空指標（Dangling Pointer）。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://luketsengtw.github.io">LukeTseng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://luketsengtw.github.io/posts/ed071748">https://luketsengtw.github.io/posts/ed071748</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://luketsengtw.github.io" target="_blank">Yaoの程式小窩</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/">程式設計</a><a class="post-meta__tags" href="/tags/%E9%9B%BB%E8%85%A6/">電腦</a><a class="post-meta__tags" href="/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/">資料結構</a></div><div class="post-share"><div class="social-share" data-image="/img/data_structure_cover.png" data-sites="facebook, twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/9b68f650" title="【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）"><img class="cover" src="/img/data_structure_cover.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）</div></div><div class="info-2"><div class="info-item-1">【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式） 歡迎你點入本篇文章！我是 LukeTseng，本系列文章主要整理自學資料結構的一些知識，如果你喜歡我的文章，麻煩您不吝嗇的在文章底下按下一顆愛心，或是追蹤我唷～ 最後更新時間： 堆疊（Stack） 特性：後進先出（LIFO：Last In First Out） 資料只能在頂端（Top）做堆入（Push），跟移除（Pop）。 Image Source：Stack Data Structure and Implementation in Python, Java and C/C++ 應用： Ctrl + Z 復原功能 函式呼叫 括號匹配 DFS（Depth First Search：深度優先搜尋） 時間複雜度： 堆入（Push）： $O(1)$ 移除（Pop）： $O(1)$ 優點： 記憶體管理高效：資料只在頂端操作，記憶體配置連續可預測。在系統層級（如 Call Stack），比堆積（Heap）快很多。 存取速度快（$O(1)$）：無論堆疊有多大，Push 跟 Pop 的時間複雜度永遠是 $O(1)$ 。 防資...</div></div></div></a><a class="pagination-related" href="/posts/2945dd9b" title="【C++】競程筆記（背包問題）"><img class="cover" src="/img/cpp_cover.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【C++】競程筆記（背包問題）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（背包問題） 題目範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 最後更新時間： 什麼是背包問題 背包問題（Knapsack Problem）是一種組合最佳化的 NP-Complete 問題，有著多種變形，其中最基礎的是「0/1 背包問題」。 在 DP 裡面，背包問題是最經典且常見的題型之一。 01 背包問題 Problem Source：https://oj.ntucpc.org/problems/801 所謂 0 1 就是物品可拿或不拿。 題目敘述： 有 $N$ 個物品編號 $1 \sim N$ ，第 $i$ 個物品的重量和價值分別是 $w_i$ 和 $v_i$ 。學姐打算從這 $N$ 個物品選其中一些帶走，但她只有大小為 $W$ 的背包，也就是說她選擇的物品總重不能超過 $W$ 。請問背包能容納的物品的總價值最大是多少？ 如果直接定義 $dp[i]$ 是前 $i$ 個物品的最大總價值，是不實際的，因為還要考慮到 $W$ 重量的因素。 因此用到二維 DP 觀念：$dp[i][j]$ 為前 $i$ 個物品且背包當前容量限制為 $j$ 時，能獲得...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/9b68f650" title="【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）"><img class="cover" src="/img/data_structure_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-04</div><div class="info-item-2">【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）</div></div><div class="info-2"><div class="info-item-1">【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式） 歡迎你點入本篇文章！我是 LukeTseng，本系列文章主要整理自學資料結構的一些知識，如果你喜歡我的文章，麻煩您不吝嗇的在文章底下按下一顆愛心，或是追蹤我唷～ 最後更新時間： 堆疊（Stack） 特性：後進先出（LIFO：Last In First Out） 資料只能在頂端（Top）做堆入（Push），跟移除（Pop）。 Image Source：Stack Data Structure and Implementation in Python, Java and C/C++ 應用： Ctrl + Z 復原功能 函式呼叫 括號匹配 DFS（Depth First Search：深度優先搜尋） 時間複雜度： 堆入（Push）： $O(1)$ 移除（Pop）： $O(1)$ 優點： 記憶體管理高效：資料只在頂端操作，記憶體配置連續可預測。在系統層級（如 Call Stack），比堆積（Heap）快很多。 存取速度快（$O(1)$）：無論堆疊有多大，Push 跟 Pop 的時間複雜度永遠是 $O(1)$ 。 防資...</div></div></div></a><a class="pagination-related" href="/posts/e51c65a9" title="【C++】競程筆記（資料結構：Binary Tree）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="info-item-2">【C++】競程筆記（資料結構：Binary Tree）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（資料結構：Binary Tree） 程式碼範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 簡介 樹（Tree）在電腦科學領域是一個由「節點」（Node）和「邊」所組成的圖形，如圖： Image Source：https://www.geeksforgeeks.org/dsa/binary-tree-data-structure/ 基本術語 節點（Node）： 如 1、2、3、4 等這些數字被圓圈包起來的就是一個節點。 根節點（Root）： 指的是最上層的節點，沒有父節點，如 1 就是根節點 Root。 子節點（Child）： 位於某節點之下的直接後繼節點，如 1 底下的 2 跟 3 都是 1 的子節點；2 底下的 4 跟 5 都是 2 的子節點。 父節點（Parent）： 反之，父節點為子節點的上層節點。1 是 2 跟 3 的父節點，2 是 4 跟 5 的父節點。 葉節點（Leaf）： 沒有任何子節點的節點。如 8, 5, 9, 10 都沒有子節點，所以稱為葉節點。 深度（Depth）： 根節點的深度定義為 0...</div></div></div></a><a class="pagination-related" href="/posts/d2565158" title="【C++】競程筆記（資料結構：Heap）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-20</div><div class="info-item-2">【C++】競程筆記（資料結構：Heap）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（資料結構：Heap） 程式碼範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 簡介 Heap（堆積），是一個完全二元樹的資料結構，主要應用於優先佇列（priority queue）中。 由於他是完全二元樹結構，所以： 除了最底層外，其他每一層都是滿的。 最底層節點從左到右依序填滿。 樹上的每一個節點儲存一個可以比較大小的鍵值（key），並支援以下操作： 插入一個鍵值 詢問目前最大的鍵值 刪除最大的鍵值 From NTUCPC Guide Heap 通常遵守下列其中一種堆積性質： 最小堆（Min-Heap）：每個節點的值都 $\leq$ 其子節點的值。（根節點是整棵樹中最小的元素） 最大堆（Max-Heap）：每個節點的值都 $\ge$ 其子節點的值。（根節點是整棵樹中最大的元素） Image Source：https://www.geeksforgeeks.org/dsa/heap-data-structure/ 以下網站有可以滑動的視窗，展示哪一種是 invalid heap，哪一種是 valid heap。 https://w...</div></div></div></a><a class="pagination-related" href="/posts/6caeb033" title="【C++】競程筆記（資料結構：set）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-21</div><div class="info-item-2">【C++】競程筆記（資料結構：set）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（資料結構：set） 程式碼範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 簡介 set 是基於紅黑樹（Red-black tree）所實現的，紅黑樹是一種自平衡避免退化的二元搜尋樹，而因為 STL 幫我們實作出來了，所以不用再重造輪子。 所以 set 在查詢、插入、刪除這方面都是對數時間 $O(logn)$ 。 另外 set 也是一種關聯式容器（Associative Container），就是使用 key 來做資料存取（set 以輸入的 value 作為 key，可查找 value 是否存在 set 中）。 關聯式容器也可再細分為有序（ordered）與無序（unordered）。 set 特性 唯一性： set 中的元素不能重複出現，若 insert 重複值，會自動被忽略。 有序性： set 中的元素會依照升序（預設）自動排序，可改成降序。 無法直接修改： 因為直接修改會破壞 set 的有序性，所以要改的話要先刪除再插入。 語法（Syntax） 1set&lt;T, comp&gt; s; T：在 set 中元素的資料型...</div></div></div></a><a class="pagination-related" href="/posts/f497d459" title="【C++】競程筆記（資料結構：Unordered set &#x2F; map）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-22</div><div class="info-item-2">【C++】競程筆記（資料結構：Unordered set &#x2F; map）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（資料結構：Unordered set / map） 程式碼範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 簡介 Unordered set / map 皆為無序的（unordered）關聯式容器，內部實作原理皆是 Hash（雜湊），對於每次操作的時間複雜度都是 $O(1)$ 。如果此資料結構發生碰撞的話，最壞的時間複雜度會到 $O(n)$ 。 那既然都無序了，所以就字面上意思，輸出的元素不一定會照著順序排。 Unordered set / map 提供了較快的操作速度，在操作上面也與原本的 set / map 無異，基本上都相通。 另外兩者的標頭檔都有稍微更改： 12#include &lt;unordered_set&gt;#include &lt;unordered_map&gt; 雜湊（Hash）介紹 雜湊函式（英語：Hash function）又稱雜湊演算法，是一種從任何一種資料中建立小的數字「指紋」的方法。雜湊函式把訊息或資料計算成摘要，使得資料量變小，將資料的格式固定下來。該函式將資料打亂混合，重新建立一個叫做雜湊值（又叫雜湊值）（...</div></div></div></a><a class="pagination-related" href="/posts/79f429f" title="【C++】競程筆記（分治法 D&amp;C）"><img class="cover" src="/img/cpp_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-25</div><div class="info-item-2">【C++】競程筆記（分治法 D&amp;C）</div></div><div class="info-2"><div class="info-item-1">【C++】競程筆記（分治法 D&amp;C） 程式碼範例參考：NTUCPC Guide，此筆記僅為個人學習用途。 Introducing Divide and Conquer Divide and Conquer 英翻中為分治法，這是一個把大問題切分成多個子問題，最後從這些子問題合併來求得主問題解答的一種方法。 而 Divide and Conquer 的步驟主要有三項： Divide：把原問題拆成多個小且類似的子問題，直到無法再細分。 Conquer：用遞迴解決這些子問題；若遇到規模足夠小的「基本情況（base case）」，則直接輸出答案。 Merge：合併子問題得到最終解，一旦較小的子問題被解決，則遞迴合併所有子問題得到更大問題的答案。 例題：王老先生 Problem Source：https://tioj.sprout.tw/problems/114 題目敘述： 有個正方形土地 $N \times N$ ， $N$ 為 $2$ 的正整數次方。 有一格子 $(X, Y)$ 已被王老先生選走了，你要放 $\frac{N \times N - 1}{3}$ 個 3 格的 L...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">LukeTseng</div><div class="author-info-description">一個軟硬體都愛的資訊人，也是個無名的程式熱愛者。目前仍主要活躍於 Hackmd 平台上，基本上本站與此同步更新。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/LukeTsengTW"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/LukeTsengTW" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#hdhfbb"></i></a><a class="social-icon" href="https://hackmd.io/@LukeTseng" rel="external nofollow noreferrer" target="_blank" title="Hackmd"><i class="fas fa-file-lines" style="color:#4e44fe"></i></a><a class="social-icon" href="https://www.instagram.com/moonouo_" rel="external nofollow noreferrer" target="_blank" title="Instagram"><i class="fab fa-square-instagram" style="color:#dd2a7b"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">【考試向】資料結構筆記（鏈結串列）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%96%AE%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%EF%BC%88Singly-Linked-list%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">單向鏈結串列（Singly Linked list）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A3%E5%88%97-v-s-%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">陣列 v.s. 鏈結串列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B5%84%E6%88%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">組成的基本要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%9F%BA%E6%9C%AC%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">C 程式實作：建立基本鏈結串列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.4.</span> <span class="toc-text">插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%87%B3%E6%9C%80%E5%89%8D%E9%9D%A2"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">插入至最前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%87%B3%E6%9C%80%E5%BE%8C"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">插入至最後</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%87%B3%E6%9F%90%E7%AF%80%E9%BB%9E%E5%BE%8C%E6%96%B9"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">插入至某節點後方</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%AA%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.5.</span> <span class="toc-text">刪除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%AA%E9%99%A4%E6%9C%80%E5%89%8D%E9%9D%A2"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">刪除最前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%AA%E9%99%A4%E5%B0%BE%E7%AB%AF"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">刪除尾端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%AA%E9%99%A4%E7%89%B9%E5%AE%9A%E7%AF%80%E9%BB%9E"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">刪除特定節點</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.6.</span> <span class="toc-text">C 程式實作：插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E5%88%AA%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.7.</span> <span class="toc-text">C 程式實作：刪除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A9%E5%96%AE%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E4%B8%B2%E6%8E%A5"><span class="toc-number">1.1.8.</span> <span class="toc-text">兩單向鏈結串列串接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E5%85%A9%E5%96%AE%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E4%B8%B2%E6%8E%A5"><span class="toc-number">1.1.9.</span> <span class="toc-text">C 程式實作：兩單向鏈結串列串接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%89%E5%96%AE%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%EF%BC%9A%E4%B8%89%E6%8C%87%E6%A8%99%E6%B3%95"><span class="toc-number">1.1.10.</span> <span class="toc-text">反轉單向鏈結串列：三指標法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E5%8F%8D%E8%BD%89%E5%96%AE%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97"><span class="toc-number">1.1.11.</span> <span class="toc-text">C 程式實作：反轉單向鏈結串列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%99%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%EF%BC%88Doubly-Linked-List%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">雙向鏈結串列（Doubly Linked List）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E9%9B%99%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E5%AE%9A%E7%BE%A9"><span class="toc-number">1.2.1.</span> <span class="toc-text">C 程式實作：雙向鏈結串列定義</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.2.2.</span> <span class="toc-text">插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%87%B3%E6%9C%80%E5%89%8D%E7%AB%AF"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">插入至最前端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%87%B3%E6%9C%80%E5%B0%BE%E7%AB%AF"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">插入至最尾端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%87%B3%E7%89%B9%E5%AE%9A%E7%AF%80%E9%BB%9E"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">插入至特定節點</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%AA%E9%99%A4%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.2.3.</span> <span class="toc-text">刪除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%AA%E9%99%A4%E6%9C%80%E5%89%8D%E9%9D%A2-2"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">刪除最前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%AA%E9%99%A4%E6%9C%80%E5%BE%8C%E9%9D%A2"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">刪除最後面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%AA%E9%99%A4%E7%89%B9%E5%AE%9A%E7%AF%80%E9%BB%9E-2"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">刪除特定節點</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.2.4.</span> <span class="toc-text">C 程式實作：插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E5%88%AA%E9%99%A4%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.2.5.</span> <span class="toc-text">C 程式實作：刪除操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%92%B0%E7%8B%80%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%EF%BC%88Circular-Linked-List%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">環狀鏈結串列（Circular Linked List）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B5%84%E6%88%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">組成的基本要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%9E%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">類型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E5%96%AE%E5%90%91%E7%92%B0%E7%8B%80%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">C 程式實作：單向環狀鏈結串列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E7%9A%84%E6%87%89%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">鏈結串列的應用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E8%A1%A8%E7%A4%BA%E5%A0%86%E7%96%8A%EF%BC%88Stack%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">用鏈結串列表示堆疊（Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Push-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Push 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pop-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">Pop 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E9%A0%82%E7%AB%AF%EF%BC%88peek%EF%BC%89"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">存取頂端（peek）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E4%BB%A5%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E5%AF%A6%E7%8F%BE%E5%A0%86%E7%96%8A"><span class="toc-number">1.4.2.</span> <span class="toc-text">C 程式實作：以鏈結串列實現堆疊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BD%87%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">用鏈結串列表示佇列（Queue）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#enqueue-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">enqueue 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dequeue-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">dequeue 操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BC%8F%E5%AF%A6%E4%BD%9C%EF%BC%9A%E4%BB%A5%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E5%AF%A6%E7%8F%BE%E4%BD%87%E5%88%97"><span class="toc-number">1.4.4.</span> <span class="toc-text">C 程式實作：以鏈結串列實現佇列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B8%BD%E6%95%B4%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">總整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A3%E5%88%97-v-s-%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">陣列 v.s. 鏈結串列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%96%AE%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%EF%BC%88Singly-Linked-List%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">單向鏈結串列（Singly Linked List）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B5%90%E6%A7%8B"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">結構</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A6%8B%E6%93%8D%E4%BD%9C%E8%88%87%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">常見操作與時間複雜度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%89%E5%96%AE%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%EF%BC%88Three-Pointer-Method%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">反轉單向鏈結串列（Three-Pointer Method）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%99%E5%90%91%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%EF%BC%88Doubly-Linked-List%EF%BC%89-2"><span class="toc-number">1.5.4.</span> <span class="toc-text">雙向鏈結串列（Doubly Linked List）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B5%90%E6%A7%8B-2"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">結構</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E9%BB%9E"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">特點</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A6%8B%E6%93%8D%E4%BD%9C%E8%88%87%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6-2"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">常見操作與時間複雜度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%92%B0%E7%8B%80%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%EF%BC%88Circular-Linked-List%EF%BC%89-2"><span class="toc-number">1.5.5.</span> <span class="toc-text">環狀鏈結串列（Circular Linked List）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%9E%E5%9E%8B-2"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">類型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6%EF%BC%88%E5%96%AE%E5%90%91%E7%92%B0%E7%8B%80%EF%BC%89"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">時間複雜度（單向環狀）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E7%9A%84%E5%AF%A6%E9%9A%9B%E6%87%89%E7%94%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">鏈結串列的實際應用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E5%AF%A6%E4%BD%9C%E5%A0%86%E7%96%8A%EF%BC%88Stack%EF%BC%89"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">以鏈結串列實作堆疊（Stack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97%E5%AF%A6%E4%BD%9C%E4%BD%87%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">以鏈結串列實作佇列（Queue）</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>資料結構系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ed071748" title="【考試向】資料結構筆記（鏈結串列）"><img src="/img/data_structure_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【考試向】資料結構筆記（鏈結串列）"></a><div class="content"><a class="title" href="/posts/ed071748" title="【考試向】資料結構筆記（鏈結串列）">【考試向】資料結構筆記（鏈結串列）</a><time datetime="2026-01-08T13:01:07.000Z" title="發表於 2026-01-08 21:01:07">2026-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9b68f650" title="【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）"><img src="/img/data_structure_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）"></a><div class="content"><a class="title" href="/posts/9b68f650" title="【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）">【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）</a><time datetime="2026-01-04T15:29:01.000Z" title="發表於 2026-01-04 23:29:01">2026-01-04</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2945dd9b" title="【C++】競程筆記（背包問題）"><img src="/img/cpp_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【C++】競程筆記（背包問題）"></a><div class="content"><a class="title" href="/posts/2945dd9b" title="【C++】競程筆記（背包問題）">【C++】競程筆記（背包問題）</a><time datetime="2026-01-14T08:37:24.000Z" title="發表於 2026-01-14 16:37:24">2026-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ed071748" title="【考試向】資料結構筆記（鏈結串列）"><img src="/img/data_structure_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【考試向】資料結構筆記（鏈結串列）"></a><div class="content"><a class="title" href="/posts/ed071748" title="【考試向】資料結構筆記（鏈結串列）">【考試向】資料結構筆記（鏈結串列）</a><time datetime="2026-01-08T13:01:07.000Z" title="發表於 2026-01-08 21:01:07">2026-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9b68f650" title="【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）"><img src="/img/data_structure_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）"></a><div class="content"><a class="title" href="/posts/9b68f650" title="【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）">【考試向】資料結構筆記（堆疊、佇列、環狀佇列、後序表示式）</a><time datetime="2026-01-04T15:29:01.000Z" title="發表於 2026-01-04 23:29:01">2026-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8a073873" title="【C++】競程筆記（多維 DP、LCS 最長共同子序列 習題練習）"><img src="/img/cpp_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【C++】競程筆記（多維 DP、LCS 最長共同子序列 習題練習）"></a><div class="content"><a class="title" href="/posts/8a073873" title="【C++】競程筆記（多維 DP、LCS 最長共同子序列 習題練習）">【C++】競程筆記（多維 DP、LCS 最長共同子序列 習題練習）</a><time datetime="2026-01-01T13:20:18.000Z" title="發表於 2026-01-01 21:20:18">2026-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a6f0427e" title="【C++】競程筆記（多維 DP、LCS 最長共同子序列）"><img src="/img/cpp_cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【C++】競程筆記（多維 DP、LCS 最長共同子序列）"></a><div class="content"><a class="title" href="/posts/a6f0427e" title="【C++】競程筆記（多維 DP、LCS 最長共同子序列）">【C++】競程筆記（多維 DP、LCS 最長共同子序列）</a><time datetime="2025-12-27T14:49:33.000Z" title="發表於 2025-12-27 22:49:33">2025-12-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/data_structure_cover.png)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2024 - 2026 By LukeTseng</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主題 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="繁簡轉換">繁</button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"none"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{let e=window.walineFn||null;const n="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,t={lang:"zh-TW",locale:{seconds:"秒前",minutes:"分鐘前",hours:"小時前",days:"天前",now:"剛剛",gif:"表情包",gifSearchPlaceholder:"搜尋 gif 動圖",comment:"留言",placeholder:"歡迎留言，請務必友善發言，減少衝突，讓世界更美好～"},emoji:["https://unpkg.com/@waline/emojis@1.0.1/tw-emoji"]},i=(e,i=document,o=window.location.pathname)=>{const s=e({el:i.querySelector("#waline-wrap"),serverURL:"https://discussion-kohl.vercel.app/",pageview:!0,dark:'html[data-theme="dark"]',comment:!0,...t,path:n?o:t&&t.path||o});n&&(window.shuoshuoComment.destroyWaline=()=>{s.destroy(),i.children.length&&(i.innerHTML="",i.classList.add("no-comment"))})},o=(n,t)=>{e?i(e,n,t):btf.getCSS("https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css").then(()=>import("https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js")).then(({init:o})=>{e=o||Waline.init,i(e,n,t),window.walineFn=e})};n?window.shuoshuoComment={loadComment:o}:setTimeout(o,0)})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜尋</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5BKRW8SL" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript></div></body></html>